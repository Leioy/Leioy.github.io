<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浮动定位BFC边距合并]]></title>
    <url>%2F2017%2F12%2F%E6%B5%AE%E5%8A%A8%E5%AE%9A%E4%BD%8DBFC%E8%BE%B9%E8%B7%9D%E5%90%88%E5%B9%B6.html</url>
    <content type="text"><![CDATA[浮动元素有什么特征？对父容器、其他浮动元素、普通元素、文字分别有什么影响?特征：浮动元素会脱离正常的文档流，按照其外边距指定的位置相对于它的上一个块级元素（或父元素）显示浮动元素后面的块级元素的内容会向此浮动元素的外边距靠齐，但是边框和背景却忽略浮动元素而向上一个任意非浮动元素靠齐浮动元素后面的内联元素会向此浮动元素的外边距靠齐 float造成的影响：对其父元素的影响对于其父元素来说，元素浮动之后，它脱离当前正常的文档流，所以它也无法撑开其父元素，造成父元素的塌陷 对其兄弟元素（非浮动）的影响如果兄弟元素为块级元素，该元素会忽视浮动元素的而占据它的位置，并且元素会处在浮动元素的下层（并且无法通过z-index属性改变他们的层叠位置），但它的内部文字和其他行内元素都会环绕浮动元素。如果如果兄弟元素为内联元素，则元素会环绕浮动元素排列。 对其兄弟元素（浮动）的影响同一个方向的浮动元素：当一个浮动元素在浮动过程中碰到同一个方向的浮动元素时，它会紧跟在它们后面反方向的浮动元素：互不影响，位于同一条水平线上，当空间不够时会被挤下 清除浮动指什么？如何清除浮动？浮动会导致：（1）背景不能显示 （2）边框不能撑开 （3）margin 设置值不能正确显示清除浮动就是消除这些不良影响清除浮动可以通过使包含块的父元素变成BFC；添加伪元素，在伪元素设置clear:both来实现 有几种定位方式，分别是如何实现定位的，参考点是什么，使用场景是什么？ inherit，从父元素继承position属性的值，一般不用 static默认值,没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明 relative，生成相对定位的元素，相对于元素本身正常位置进行定位。属性值：left, top,right ,bottom，应用于对其自身进行细微调整 absolute，生成绝对定位的元素，相对于static定位以外的第一个祖先元素（offset parent）进行定位 fixed，生成绝对定位的元素，相对于浏览器窗口进行定位。属性值：left, top,right ,bottom z-index 有什么作用? 如何使用?z-index规定了元素在Z轴（距离用户远近）上的顺序，值越大(需要同属于同一个层叠上下文关系)则越靠近用户，表现就是元素在最上面。关于z-index详细说明 position:relative和负margin都可以使元素位置发生偏移?二者有什么区别position：relative可以使元素发生偏移，但是在文档流中，它仍然占据着原来的位置，所以其他同级元素的位置不会发生变化。负margin：通过负margin进行偏移的元素，它会放弃偏移前占据的空间，所以其他同级元素的位置发生了变化。 BFC 是什么？如何生成 BFC？BFC 有什么作用？举例说明BFC：块级格式化上下文，它是指一个独立的块级渲染区域，只有Block-level BOX参与，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。 CSS2.1中规定满足下列CSS声明之一的元素便会生成BFC。 根元素 float的值不为none overflow的值不为visible display的值为inline-block、table-cell、table-caption position的值为absolute或fixed 作用： 不和浮动元素重叠 如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个覆盖的现象，很多自适应的两栏布局就是这么做的。 清除元素内部浮动 只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了 嵌套元素Margin边距折叠问题的解决 按照BFC的定义，只有同属于一个BFC时，两个元素才有可能发生垂直Margin的重叠，这个包括相邻元素，嵌套元素，只要他们之间没有阻挡(例如没有边框，非空内容，padding等)就会发生margin重叠。 因此要解决margin重叠问题，只要让它们不在同一个BFC就行了，只要把父元素设为BFC就可以了。这样子元素的margin就不会和父元素的margin发生重叠了 在什么场景下会出现外边距合并？如何合并？如何不让相邻元素外边距合并？给个父子外边距合并的范例场景： 同一个BFC，且同处于普通流中的垂直相邻元素外边距合并。 父子元素的外边距合并。 空元素的外边距合并。 合并规则： 两个margin都是正值的时候，取两者的最大值； 当 margin 都是负值的时候，取的是其中绝对值较大的，然后，从0位置，负向位移； 当有正有负的时候，先取出负 margin 中绝对值中最大的，然后，和正 margin 值中最大的 margin 相加。 所有毗邻的margin要一起参与运算，不能分步进行。 不让相邻元素外边距合并的方法： 被非空内容、padding、border 或 clear 分隔开。 不在一个普通流中或一个BFC中。 margin在垂直方向上不毗邻。 123&lt;div&gt; &lt;p style="margin-top:30px"&gt;这是一段文字&lt;/p&gt;&lt;/div&gt; 相关文章]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css常见样式2]]></title>
    <url>%2F2017%2F12%2Fcss%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F2.html</url>
    <content type="text"><![CDATA[text-align: center的作用是什么，作用在什么元素上？能让什么元素水平居中text-align: center;的作用是令元素水平居中，IE6/7及IE8混杂模式中，text-align:center可以使块级元素也居中对齐。其他浏览器中，text-align:center仅作用于行内内容上。 IE 盒模型和W3C盒模型有什么区别?IE盒模型的宽高：包含了border,padding,content的值。W3C盒模型的宽高：以content的宽度高度作为width和height *{ box-sizing: border-box;}的作用是什么？设置为IE盒模型，IE盒模型的宽高包含了border,padding,content的值。使用该属性，设置盒模型的宽高时，不用去考虑内部的计算，因为设置border，padding也不会增加该盒模型的宽高。 line-height: 2和line-height: 200%有什么区别?line-height: 2：设置行高为元素本身字体大小的两倍，无论字体大小，后代都会继承两倍行高这个关系line-height: 200%：设置行高为其父元素字体大小的两倍，后代只会继承固定的行高，不会继承两倍的行高。 inline-block有什么特性？如何去除缝隙？高度不一样的inline-block元素如何顶端对齐?具有内联和块级元素的特性：不会占据一整行；可以设置宽高，margin,padding 如何去除缝隙：标签不换行；设置父元素字体大小为0，然后单独设置字体大小如何顶端对齐：vertical-align: top; CSS sprite 是什么?CSSSprites在国内很多人叫css精灵，是一种网页图片应用处理方式。它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去,再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位。 其优点在于： 减少网页的http请求，提高性能，这也是CSS Sprites最大的优点，也是其被广泛传播和应用的主要原因； 减少图片的字节：多张图片合并成1张图片的字节小于多张图片的字节总和； 减少了命名困扰：只需对一张集合的图片命名，不需要对每一个小元素进行命名提高制作效率； 更换风格方便：只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变，维护起来更加方便。 其缺点在于： 图片合成比较麻烦； 背景设置时，需要得到每一个背景单元的精确位置； 维护合成图片时，最好只是往下加图片，而不要更改已有图片 让一个元素”看不见”有几种方式？有什么区别?123456#E &#123; opacity: 0;/* 变透明，仍占据位置*/ visibility: hidden;/*消失 占位置*/ display: none;/*消失 不占位置*/ background-color: rgba(0, 0, 0, 0);/*背景透明*/&#125;]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css常见样式]]></title>
    <url>%2F2017%2F12%2Fcss%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F.html</url>
    <content type="text"><![CDATA[块级元素和行内元素分别有哪些?有哪些区别？块级元素: div , p , form, ul, li , ol, dl, form, address, fieldset, hr, menu, table行内元素：span, strong, em, br, img , input, label, select, textarea, cite 区别： 块级元素会独占一行，其宽度自动填满其父元素宽度 行内元素不会独占一行，相邻的行内元素会排列在同一行里，直到一行排不下，才会换行，其宽度随元素的内容而变化 块级元素可以设置 width, height属性，行内元素设置width, height无效 块级元素可以设置margin 和 padding。行内元素可以设置margin和padding但是水平方向有效，竖直方向无效 什么是 CSS 继承? 哪些属性能继承，哪些不能？应用样式的元素的后代会继承样式的某些属性，比如颜色和字号。这种特点称作CSS继承。不可继承的：display、margin、border、padding、background、height、min-height、max- height、width、min-width、max-width、overflow、position、left、right、top、 bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、 page-bread-before和unicode-bidi。所有元素可继承：visibility和cursor。内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、 font-family、font-size、font-style、font-variant、font-weight、text- decoration、text-transform、direction。块级元素可继承：text-indent和text-align。列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。表格元素可继承：border-collapse。 如何让块级元素水平居中？如何让行内元素水平居中?块级元素水平居中一般使用margin: 0 auto;实现。行内元素水平居中一般使用text-align: center;实现。更多居中方法参考：css水平居中，垂直居中 单行文本溢出加 …如何实现?12345#E&#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; 多行文本溢出加…参考：如何实现单行文本/多行文本溢出的省略 px, em, rem 有什么区别?px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。(引自CSS2.0手册)em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(引自CSS2.0手册)rem是CSS3新增的一个相对单位（rootem，根em），区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。 解释下面代码的作用?为什么要加引号? 字体里\5b8b\4f53代表什么?123body&#123; font: 12px/1.5 tahoma,arial,'Hiragino Sans GB','\5b8b\4f53',sans-serif;&#125; 作用：定义body标签内的所有字体大小为12px，1.5倍行距，依次尝试tahoma,arial,’Hiragino Sans GB’,’\5b8b\4f53’,sans-serif 这几种字体，取较前的设定为所用字体。为什么要加引号：因为字体名称内部有空格，不加引号易引起歧义。\5b8b\4f53：‘宋体’两个字的Unicode 编码，在此可以代替‘宋体’两个字。]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css选择器]]></title>
    <url>%2F2017%2F12%2Fcss%E9%80%89%E6%8B%A9%E5%99%A8.html</url>
    <content type="text"><![CDATA[class 和 id 的使用场景?Html中的“类”（class）可以赋予给多个不同标签，而id每篇html文档只可以存在一次，因此class多用于某种统一的样式，而id多用于“仅此一种”的样式。实践上，对于样式而言，我们常常采用class而不是id。 CSS选择器常见的有几种? 基础选择器 1.通配符选择器 * { color:red } 2.id选择器 3.类选择器 4.标签选择器 组合选择器 1.多元素选择器：以,分隔，表示同时匹配多个选择器对应的元素 2.后代选择器：以空格分隔 属性选择器 1.E[attr]：筛选出所有具有属性名为attr的属性的元素 2.E[attr=value]：筛选出所有属性attr的值为vlaue的元素 伪类选择器 1.E:link：未被访问时的样式 2.E:visited：已经被访问后的样式 3.E:hover：鼠标悬停在a链接之上的样式 4.E:active：鼠标按下但未释放时的样式 5.E:first-child：父元素的各类标签中第一个子元素且必须符合指定类型（为E） 6.E:nth-child：匹配其父元素的第n个子元素 伪元素选择器 1.E:before：在E元素之前插入的内容 2.E:after：在E元素之后插入的内容 选择器的优先级是怎样的?对于复杂场景如何计算优先级？!important &gt; 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性 优先级计算方法：先数 id选择器数量，如果id选择器数量多的选择器权重高,如果id选择器数量相同，再数类选择器数量，最后数标签。 a:link, a:hover, a:active, a:visited 的顺序是怎样的？ 为什么？a:link：选择未被访问的链接，并设置其样式a:hover：选择鼠标指针浮动在其上的元素，并设置其样式a:active：选择活动链接，并设置其样式a:visited：选择已访问的链接，并设置其样式 在W3C规范中，也规定了链接的声明顺序：在 CSS 定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。 所以正确的顺序为：a:link、a:visited、a:hover、a:active 列出你知道的选择器E:first-child 匹配元素E的第一个子元素E:link 匹配所有未被点击的链接E:visited 匹配所有已被点击的链接E:active 匹配鼠标已经其上按下、还没有释放的E元素E:hover 匹配鼠标悬停其上的E元素E:enabled 匹配表单中可用的元素E:disabled 匹配表单中禁用的元素E:checked 匹配表单中被选中的radio或checkbox元素E::selection 匹配用户当前选中的元素E:nth-child(n) 匹配其父元素的第n个子元素，第一个编号为1E:nth-last-child(n) 匹配其父元素的倒数第n个子元素，第一个编号为1E:nth-of-type(n) 与:nth-child()作用类似，但是仅匹配使用同种标签的元素E:nth-last-of-type(n) 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素E:last-child 匹配父元素的最后一个子元素，等同于:nth-last-child(1)E:first-of-type 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)E:last-of-type 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)E:only-child 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)E:only-of-type 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)E:not(selector) 匹配不符合当前选择器的任何元素 div:first-child、div:first-of-type、div :first-child和div :first-of-type的作用和区别 （注意空格的作用）:first-child选择器是选择父元素的第一个子元素，而:first-of-type选择器则是选择第一个这个类/这个标签的子元素。而空格无非是后代选择器而已，所以这四个选择器的意义分别是： div:first-child：是第一个元素的 div 标签div:first-of-type：第一个 div 标签div :first-child：div 标签下的第一个元素div :first-of-type：div 标签下每个标签的第一个元素 范例： 12345678910111213&lt;style&gt;.item1:first-child&#123; color: red;&#125;.item1:first-of-type&#123; background: blue;&#125;&lt;/style&gt;&lt;div class="ct"&gt; &lt;p class="item1"&gt;aa&lt;/p&gt; &lt;h3 class="item1"&gt;bb&lt;/h3&gt; &lt;h3 class="item1"&gt;ccc&lt;/h3&gt;&lt;/div&gt; aabbccc .item1:first-child{ color: red; } .item1:first-of-type{ background: blue; } 解释：.item1:first-child选中了item1类中第一个元素，所以内容为“aa”的p标签变红色了。.item1:first-of-type选中了item1类中所有的标签的第一个元素，所以p标签和第一个h3标签的背景变蓝了。]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css基础]]></title>
    <url>%2F2017%2F12%2Fcss%E5%9F%BA%E7%A1%80.html</url>
    <content type="text"><![CDATA[CSS的全称是什么?层叠样式表（英语：Cascading Style Sheets，简写CSS），一种用来为结构化文档（如HTML文档或XML应用）添加样式（字体、间距和颜色等）的计算机语言，由W3C定义和维护。 CSS有几种引入方式? link 和@import 有什么区别?CSS有几种引入方式四种，分别为行内样式，内嵌样式和外联样式以及@import link 和@import 有什么区别 link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。 link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。所以有时候浏览@import加载CSS的页面时开始会没有样式（就是闪烁）。 link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。 link支持使用Javascript控制DOM去改变样式；而@import不支持。 以下这几种文件路径分别用在什么地方，代表什么意思? css/a.css相对路径，当前目录下css文件夹内a.css文件 ./css/a.css相对路径，同级目录下css文件夹内a.css文件 b.css相对路径，与当前文档同级目录下b.css文件 ../imgs/a.png相对路径，上级文件夹下imgs文件夹内a.png文件 /Users/hunger/project/css/a.css绝对路径，根目录下对应路径的文件 /static/css/a.css绝对路径，根目录下对应路径的文件 http://cdn.jirengu.com/kejian1/8-1.png绝对路径，表示饥人谷该网站kejian1目录下的名为8-1.png的图片地址 列出5条以上html和 css 的书写规范 一次缩进2个空格，不要使用 tab 或者混合 tab 和空格的缩进。 HTML 元素名称，属性，属性值（除非 text/CDATA），CSS 选择器，属性，属性值应该使用小写。 结尾切勿加空格空格不仅多余，而且在比较代码时会更麻烦。 在 HTML 中通过指定编码方式，CSS 中不需要指定，因为默认是 UTF-8。 使用注释来解释代码：包含的模块，功能以及优点。]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[form表单]]></title>
    <url>%2F2017%2F12%2Fform%E8%A1%A8%E5%8D%95.html</url>
    <content type="text"><![CDATA[form表单有什么作用？有哪些常用的input 标签，分别有什么作用？表单在网页中主要负责数据采集功能。一个表单有三个基本组成部分： 表单标签：这里面包含了处理表单数据所用CGI程序的URL以及数据提交到服务器的方法。 表单域：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等。 表单按钮：包括提交按钮、复位按钮和一般按钮；用于将数据传送到服务器上的CGI脚本或者取消输入，还可以用表单按钮来控制其他定义了处理 常见的input标签: 标签 作用 text 单行文本框 password 密码框 checkbox 多选输入框 radio 单选按钮 file 上传文件 hidden 隐藏域 submit 数据提交按钮 button 普通按钮 post 和 get 方式的区别 GET提交：请求的数据会附在URL之后(就是把数据放置在HTTP协议头中)，以?分割URL和传输数据，多个参数用&amp;连接。如果数据是英文字母数字，原样发送，如果是空格，转换为+，如果是中文其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中%XX中的XX为该符号以16进制表示的ASCII。示例：点击提交,地址跳转为 POST提交：把提交的数据放置在是HTTP包的包体中。示例：点击提交后信息并没有显示在地址栏里面因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变。 传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制 而在实际开发中存在的限制主要有： GET: 特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2K+35。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。 POST: 由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。 name属性 作为可与服务器交互数据的HTML元素的服务器端的标示，比如input、select、textarea、和button等。我们可以在服务器端根据其Name通过Request.Params取得元素提交的值。 HTML元素Input type=’radio’分组，我们知道radio button控件在同一个分组类，check操作是mutex的，同一时间只能选中一个radio，这个分组就是根据相同的Name属性来实现的。 建立页面中的锚点，我们知道&lt;a href=&quot;URL&quot;&gt;link&lt;/a&gt;是获得一个页面超级链接，如果不用href属性，而改用Name，如：&lt;a name=&quot;PageBottom&quot;&gt;&lt;/a&gt;，我们就获得了一个页面锚点。 作为对象的Identity，如Applet、Object、Embed等元素。比如在Applet对象实例中，我们将使用其Name来引用该对象。 在IMG元素和MAP元素之间关联的时候，如果要定义IMG的热点区域，需要使用其属性usemap，使usemap=”#name”(被关联的MAP元素的Name)。 某些特定元素的属性，如attribute，meta和param。例如为Object定义参数或Meta中。 radio如何分组在同一个分组里，name属性要有相同的值。12&lt;input type="radio" name="gender" value="male"&gt;&lt;input type="radio" name="gender" value="female"&gt; placeholder 属性有什么作用?可以在文本输入框内显示默认的提示字符 type=hidden隐藏域有什么作用? 举例说明 隐藏数据一起发送给服务器。 作为LocalStorage的替代品。 当有多个submit按钮时，可以用于确认是哪个按钮提交的表单。 可以用于联系多个表单。 作为全局变量使用。 作为父窗口的隐藏域，对小窗口传参。 input type=’submit’ 和type=’button’ 有什么区别在一个页面上话一个按钮有四种方法：1234567&lt;!-- 这就是一个按钮。如果你不写javascript 的话，按下去什么也不会发生。 --&gt;&lt;input type="button"&gt;&lt;!-- 这样的按钮用户点击之后会自动提交 form，除非你写了javascript 阻止它。 --&gt;&lt;input type="submit" /&gt;&lt;!-- 这个按钮放在 form 中也会点击自动提交，比前两个的优点是按钮的内容不光可以有文字，还可以有图片等多媒体内容。（当然，前两个用图片背景也可以做到）。它的缺点是不同的浏览器得到的 value 值不同；可能还有其他的浏览器兼容问题 --&gt;&lt;button&gt;&lt;!-- 其他标签，例如 a, img, span, div，然后用图片把它伪装成一个按钮。 --&gt;]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端利用动态rem实现自适应布局（一）]]></title>
    <url>%2F2017%2F12%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%88%A9%E7%94%A8%E5%8A%A8%E6%80%81rem%E5%AE%9E%E7%8E%B0%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[什么是rem这个单位代表根元素的 font-size 大小（例如 &lt;html&gt; 元素的font-size）当用在根元素的font-size上面时 ，它代表了它的初始值(译者注:默认的初始值是html的默认的font-size大小,比如当未在根元素上面设置font-size大小的时候,此时的1rem==1em,当设置font-size=2rem的时候,就使得页面中1rem的大小相当于html的根字体默认大小的2倍,当然此时页面中字体的大小也是html的根字体默认大小的2倍)。 自适应的精髓就是让盒子的大小，间距等与视窗的大小相关。如何用rem做到这一点？我们可以通过js来获取视窗的宽度，然后给html一个font-size值，让两者关联起来 有这样一个需求。有四个div盒子，每个盒子的宽度是高度的两倍，盒子中间的间距是周围间距的两倍，效果如下。并且在不同屏幕宽度小都能呈现出相同的效果 123var pageWidth = window.innerWidth document.write(`&lt;style&gt;html&#123;font-size:$&#123;pageWidth/10&#125;px;&#125;&lt;/style&gt;`) &lt;/script&gt; 12345678&lt;body&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt;box1&lt;/div&gt; &lt;div class="child"&gt;box2&lt;/div&gt; &lt;div class="child"&gt;box3&lt;/div&gt; &lt;div class="child"&gt;box4&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 12345678910111213141516171819* &#123; margin: 0; padding: 0; box-sizing: border-box; &#125;body &#123; font-size: 16px; &#125;clear::after &#123; content: ''; display: block; clear: both; &#125;.child &#123; width: 4rem; height: 2rem; margin: 0.5rem 0.5rem; float: left; background: #8e8585; &#125; 这样有一个问题，我每次都要计算才能得到给多少rem值，这样很麻烦。我们可以通多scss里面的函数解决这个问题。123456789101112131415161718192021@function px2rem($px)&#123; @return $px/$designWidth *10+ rem&#125;$designWidth : 320;* &#123;margin: 0;padding: 0;box-sizing: border-box;&#125;body &#123;font-size: 16px;&#125;clear::after&#123; content: ''; display: block; clear: both;&#125;.child &#123; width: px2rem(128); height: px2rem(64); margin: px2rem(16) px2rem(16); float: left; background: #8e8585;&#125; 结尾：这只是一个简单的利用动态rem实现自适应的思路，更多的细节，需要持续关注。附上一篇大漠老师的文章使用Flexible实现手淘H5页面的终端适配]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML知识]]></title>
    <url>%2F2017%2F12%2FHTML%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[HTML、XML、XHTML 有什么区别HTML、XML和XHTML都是标准通用标记语言的一个子集。 HTML被设计用来显示数据，其焦点是数据的外观,是最早写网页的语言，但是由于时间早，规范不是很好，大小写混写且编码不规范； XML被设计用来传输和存储数据，其焦点是数据的内容。 XHTML是更严格更纯净的 HTML 版本，是作为一种 XML 应用被重新定义的 HTML，设计的目的是为了取代HTML以适应未来网络更多的需求。 它们都可以用来开发网页，但就目前来看，网页开发中HTML还是占绝对的主流，现在最新版本HTML5也备受推崇。可拓展标记语言XML广泛运用于各种应用程序中数据的存储（例如各种配置文件）和应用程序间的数据传输，可以说是一项必须掌握的技术。至于可扩展超文本标记语言XHTML，在2009年W3C已经宣布停止了对XHTML2的开发，转而大力支持HTML5。 怎样理解 HTML 语义化语义化的HTML就是写出的HTML代码，根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。语义化有助于： 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重。 在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看。 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 怎样理解内容与样式分离的原则 写 HTML 仅处理内容，只考虑 HTML 的结构和语义化，避免出现属性样式。 写 JS 的时候，尽量不使用 JS直接操作样式。 页面展现的所有样式，都由CSS来负责实现。 有哪些常见的meta标签12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- 关键字，搜所引擎 SEO --&gt;&lt;!-- 关键字，搜所引擎 SEO --&gt;&lt;meta http-equiv="keywords" content="关键字1,关键字2,..."&gt; &lt;!-- 页面描述 --&gt;&lt;meta http-equiv="description" content="网页描述"&gt; &lt;!-- content的取值为webkit,ie-comp,ie-stand之一，区分大小写，分别代表用webkit内核，IE兼容内核，IE标准内核。 --&gt;&lt;meta name="renderer" content="webkit|ie-comp|ie-stand"&gt;&lt;!-- 若页面需默认用极速核，增加标签： --&gt;&lt;meta name="renderer" content="webkit"&gt;&lt;!-- 若页面需默认用ie兼容内核，增加标签： --&gt;&lt;meta name="renderer" content="ie-comp"&gt;&lt;!-- 若页面需默认用ie标准内核，增加标签： --&gt;&lt;meta name="renderer" content="ie-stand"&gt;&lt;!-- 如果安装了GCF，则使用GCF来渲染页面，如果没有安装GCF，则使用最高版本的IE内核进行渲染。X-UA-Compatible：这是个是IE8的专用标记,用来指定IE8浏览器去模拟某个特定版本的IE浏览器的渲染方式(比如人见人烦的IE6)，以此来解决部分兼容问题。 --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" &gt;&lt;!-- 强制页面在当前窗口以独立页面显示。 --&gt;&lt;meta http-equiv="Window-target" content="_top"&gt;&lt;!-- 自动刷新，并指向新的页面 --&gt;&lt;meta http-equiv="Refresh" content="2；URL=http://"&gt;&lt;!-- 禁止浏览器缓存 --&gt;&lt;!-- 是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出用法： --&gt;&lt;meta http-equiv="pragram" content="no-cache"&gt; &lt;!-- 清除缓存（再访问这个网站要重新下载！） --&gt;&lt;meta http-equiv="cache-control" content="no-cache, must-revalidate"&gt; &lt;!-- 设定网页的到期时间 --&gt;&lt;meta http-equiv="expires" content="0"&gt; &lt;!-- 手机端 --&gt;&lt;meta name="format-detection" content="telphone=no, email=no"/&gt;&lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;&lt;meta name="apple-mobile-web-app-status-bar-style" content="black"/&gt;&lt;!-- 设置苹果工具栏颜色 --&gt;&lt;!-- 不让百度转码 --&gt;&lt;meta http-equiv="Cache-Control" content="no-siteapp" /&gt;&lt;!-- 不缓存 --&gt;&lt;meta http-equiv="cache-control" content="no-cache" /&gt;&lt;!-- 初始化设备 --&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimal-ui" /&gt;&lt;!-- 网站开启对iphone私有 web app 程序的支持 --&gt;&lt;meta content="yes" name="apple-mobile-web-app-capable" /&gt;&lt;!-- 改变顶部状态条的颜色 iphone私有的属性--&gt;&lt;meta content="black" name="apple-mobile-web-app-status-bar-style" /&gt; 文档声明的作用?严格模式和混杂模式指什么?&lt;!doctype html&gt;的作用文档声明的作用文档声明指出阅读程序应该用什么规则集来解释文档中的标记。在web文档的情况下，“阅读程序”通常是浏览器或者校验器这样的一个程序，“规则”则是w3c所发布的一个文档类型定义（dtd）中包含的规则。每个dtd都包括一系列标记、attributes和properties，它们用于标记web文档的内容；此外还包括一些规则，它们规定了哪些标记能出现在其他哪些标记中。每个web建议标准（比如html 4 frameset和xhtml 1.0 transitional）都有自己的dtd。假如文档中的标记不遵循doctype声明所指定的dtd，这个文档除了不能通过代码校验之外，还有可能无法在浏览器中正确显示。对于标记不一致的问题，浏览器相较于校验器来说更宽容。但是，不正确的doctype声明经常导致网页不正确显示，或者导致它们根本不能显示。 严格模式和混杂模式指什么严格模式：又称标准模式，是指浏览器按照 W3C 标准解析代码。 混杂模式：又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码。 如何区分：浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。 如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。（严格 DTD ——严格模式）包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。（DTD不存在或者格式不正确——混杂模式）HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。（ HTML5 没有严格和混杂之分）意义：严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，每个浏览器都有自己的解析模式。 &lt;!doctype html&gt;的作用声明文档的解析类型(document.compatMode)，避免浏览器的怪异模式 document.compatMode：BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。CSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面。 这个属性会被浏览器识别并使用，但是如果你的页面没有DOCTYPE的声明，那么compatMode默认就是BackCompat,这也就是绝望和黑暗的开始 – 浏览器按照自己的方式解析渲染页面，那么，在不同的浏览器就会显示不同的样式。如果你的页面添加了&lt;!DOCTYPE html&gt;那么，那么就等同于开启了标准模式，那么浏览器就得老老实实的按照W3C的标准解析渲染页面，这样一来，你的页面在所有的浏览器里显示的就都是一个样子了。这就是&lt;!DOCTYPE html&gt;的作用。 浏览器乱码的原因是什么？如何解决造成html网页乱码原因主要是html源代码内中文字内容与html编码不同造成。但无论是哪种情况造成乱码解决方法都是在网页开始时候设置网页编码 常见的浏览器有哪些，什么内核 浏览器 市场占有率 内核 Chrome 58.64% WebKit/Chromium引擎 Internet Explorer 18.95% Trident Firefox 11.79% Gecko Edge 5.61% Trident Safari 3.37% WebKit Opera 1.18% Presto]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
</search>
