<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BFC]]></title>
    <url>%2F2018%2F03%2FBFC.html</url>
    <content type="text"><![CDATA[到底什么是BFC？很多人都对BFC不理解，其实我也不理解，因为规范上对BFC的解释实在是太抽象了。 CSS规范中对BFC的描述 9.4.1 块格式化上下文浮动，绝对定位的元素，非块盒的块容器（例如inline-blocks，table-cells和table-captions），以及’overflow’不为’visible’的块盒（当该值已被传播到视口时除外（except when that value has been propagated to the viewport））会为其内容建立新的块格式化上下文 在一个块格式化上下文中，盒在垂直方向一个接一个地放置，从包含块的顶部开始。两个兄弟盒之间的垂直距离由’margin’属性决定。同一个块格式化上下文中的相邻块级盒之间的垂直外边距会合并 在一个块格式化上下文中，每个盒的左外边界（left outer edge）挨着包含块的左外边界（对于从右向左的格式化，右外边界挨着）。即使存在浮动（尽管一个盒的行框可能会因为浮动而收缩 译注：环绕浮动元素放置的行框比正常的行短一些），这也成立。除非该盒建立了一个新的块格式化上下文（这种情况下，该盒自身可能会因为浮动变窄）对于W3C标准对BFC的解释，我相信大部分人都看不懂，完全不明所以。 那么我们来看看稍微正常的一点的解释 MDN对BFC的描述 块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的部分，是块级盒布局发生的区域，也是浮动元素与其他元素交互的区域。 创建块格式化上下文的方式如下： 根元素或其它包含它的元素 浮动元素 (元素的 float 不是 none) 绝对定位元素 (元素的 position 为 absolute 或 fixed) 内联块元素 (元素具有 display: inline-block) 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性) 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性) 匿名表格元素 (元素具有 display: table, table-row, table-row-group, table-header-group, table-footer-group [分别是HTML tables, table rows, table bodies, table headers and table footers的默认属性]，或 inline-table ) overflow 值不为 visible 的块元素， display 值为 flow-root 的元素 contain 值为 layout, content, 或 strict 的元素 弹性元素 (display: flex 或 inline-flex元素的子元素) 网格元素 (display: grid 或 inline-grid 元素的子元素) 多列容器 (元素的 column-count 或 column-width 不为 auto 即视为多列，column-count: 1的元素也属于多列) 即便具有 column-span: all 的元素没有被包裹在一个多列容器中，column-span: all 也始终会创建一个新的格式化上下文。 块格式化上下文包含创建它的元素内的所有内容。 块格式化上下文对于定位 (参见 float) 与清除浮动 (参见 clear) 很重要。定位和清除浮动的样式规则只适用于处于同一块格式化上下文内的元素。浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只能清除同一块格式化上下文中在它前面的元素的浮动。Margin collapsing也只发生在属于同一块格式化上下文的块级元素之间。 张鑫旭的BFC的描述 BFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。啪啦啪啦特性什么的，一言难尽，大家可以自行去查找，我这里不详述，免得乱了主次，总之，记住这么一句话：BFC元素特性表现原则就是，内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素。所以，避免margin穿透啊，清除浮动什么的也好理解了。 BFC FUCK，BFC到底是什么？先思考一个问题：什么是色情？ 联邦最高法院大法官斯图尔特更有一句名言 我不知道什么是色情，不过，我看了之后，就能知道 类似的：1.我不知道什么是 BFC2.但是你写出样式，我就知道这是不是 BFC我们不用知道BFC的定义，只需要知道它的特性和功能。 功能1：爸爸管儿子用BFC的特性包住浮动元素（这不是清除浮动）http://js.jirengu.com/basixasuwu/2/edit 在父元素上设置float(不为none)，绝对定位，display:inline-block都能触发BFC从而使得包住浮动元素。虽然达到包住浮动元素的效果，但是父元素的属性变化了，比如float。我只想简单的生成一个BFC能不能不要搞那么多幺蛾子？有一个属性：display:flow-root可以满足你。 功能2：兄弟之间划清界限http://js.jirengu.com/sokuxolori/1/edit?html,css,output可以利用这种特性做一个左边固定宽度，右侧自适应的布局]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十大排序之冒泡排序]]></title>
    <url>%2F2018%2F02%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[算法描述冒泡排序（Bubble Sort）是一种简单直观的排序算法。它重复地走访过要排序的数列，依次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 时间复杂度 空间复杂度 稳定性 时间复杂度：O(n^2) 空间复杂度：O(1) 稳定性：稳定 算法实现1234567891011121314151617let arr = [32,2,7,10,8,18,21,1,100,86,16,35]function bubbleSort(arr) &#123; let len = arr.length let temp; for(let i = 0; i &lt; len; i++) &#123; for(let j = 0; j &lt; len - 1 - i; j++) &#123; if(arr[j] &gt; arr[j+1]) &#123; temp = arr[j+1] arr[j+1] = arr[j] arr[j] = temp &#125; &#125; &#125; return arr&#125;console.log(bubbleSort(arr)) //[ 1, 2, 7, 8, 10, 16, 18, 21, 32, 35, 86, 100 ]]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js中的this到底是什么]]></title>
    <url>%2F2018%2F02%2Fthis.html</url>
    <content type="text"><![CDATA[我们在写代码经常要用到this这个关键字，但是初学者会常常搞不懂this的值到底指的是什么。 先来看一个例子：12345678let obj = &#123; foo() &#123; console.log(this) &#125;&#125;let bar = obj.fooobj.foo() //打印出来的是objbar() //打印出来的是window 为什么这两个输出不一样？ 首先需要从函数调用开始说起 我们调用一个函数时常常这样调用：12fn(a,b)obj.method.fn(a,b) 其实还有一种调用形式1fn.call(context,a,b) /*apply作用类似，不同的是aplly传入参数是以数组的形式传入*/ call才是正常的调用形式，其他两种都是语法糖。上面的代码可以转换成下面的形式12fn(a,b) 等价于 fn.call(undefined,a,b)obj.method.fn(a,b) 等价于 obj.method.fn.call(obj.method,a,b) 那么this就好理解了，this就是call的时候传入的第一个参数。 解释一下前面的例子：12345678let obj = &#123; foo() &#123; console.log(this) &#125;&#125;let bar = obj.fooobj.foo() //相当于obj.foo.call(obj)bar() //相当于bar.call(undefined) 好了到这里我理解了，this就是call的第一个参数，那我直接bar()调用的时候并没有传入参数啊，为什么打印出来的是window 实际上你没传参数就相当于传了一个undefined。在浏览器环境中，非严格模式下，你传入的第一个参数是undefined或者null都会指向window。nodejs环境下指向global对象 总之，this的值只有在调用的时候才能确定，具体你还得看是函数调用还是方法调用。 所以每进入一层函数，this的指向都会改变，有很大的不确定性，常常搞的人晕头晃脑的。在es6中新加入了箭头函数，箭头函数不会改变this的指向，箭头函数里的this是在声明函数时就已经确定了的。 举个例子，我们可能有这么写过代码：123456789function bindEvent() &#123; $('ul').on('click','li',function() &#123; this.getData() &#125;)&#125;function getData() &#123; // do something&#125; 实际上达不到你想要的效果，前面说了this的值只有调用的时候才能确定，你咋知道是怎么调用的呢？只有读jQeury的源码或者看文档才知道，文档告诉我们this的值时被点击的元素。哎呀，好气啊，我怎么调用getData函数呢？既然this每进入一个函数都会改变，那我用个变量把this的值保存起来再用不就可以了吗12345678910function bindEvent() &#123; var _this = this $('ul').on('click','li',function() &#123; _this.getData() &#125;)&#125;function getData() &#123; // do something&#125; 这样写多麻烦，好在箭头函数为我们提供了便利123456789function bindEvent() &#123; $('ul').on('click','li',() =&gt; &#123; this.getData() &#125;)&#125;function getData() &#123; // do something&#125; 这样就好了，箭头函数内部的this你声明的时候就确定了。 看到这里，你明白了吗？如果没有，那就念三遍this的值就是call形式调用的时候传入的第一个参数。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http]]></title>
    <url>%2F2018%2F02%2FHttp.html</url>
    <content type="text"><![CDATA[DNS是什么DNS存储了域名和IP的对应关系baidu.com &gt;&gt;&gt; 111.13.101.208一个域名可以对应多个IP一个域名对应的IP是由域名所有者指定的DNS可能有缓存 OSI 七层模型指什么OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互联模型。该体系结构标准定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层），即ISO开放系统互连参考模型。在这一框架下进一步详细规定了每一层的功能，以实现开放系统环境中的互连性、互操作性和应用的可移植性关于OSI七层模型的形象解释从高层到底层分别为： 层级名称 英文名称 应用举例 描述 应用层 Application HTTP FTP TFTP SMTP SNMP DNS 网络服务与最终用户的一个接口 表示层 Presentation Layer JPEG、ASCll、DECOIC、加密格式 数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层） 会话层 Session Layer 对应主机进程，指本地主机与远程主机正在进行的会话 建立、管理、终止会话。（在五层模型里面已经合并到了应用层） 传输层 Transport TCP UDP 定义传输数据的协议端口号，以及流控和差错效验 网络层 Network ICMP IGMP IP（IPV4 IPV6） ARP RARP 进行逻辑地址寻址，实现不同网络之间的路径选择 数据链路层 Link 网卡，网桥，二层交换机等 建立逻辑连接、进行硬件地址寻址、差错效验等功能。（由底层网络定义协议） 物理层 Physical Layer 中继器，集线器，网线，HUB等 建立、维护、断开物理连接。（由底层网络定义协议） 将会话层和表示层、应用层合并为一层，称之为“五层模型”在五层模型的基础上将物理层和数据链路层合并为一层，称之为“四层模型” HTTP 的工作原理是什么？HTTP由请求和响应构成，是一个标准的客户端服务器模型（B/S）。HTTP协议永远都是客户端发起请求，服务器回送响应。一次HTTP操作称为一个事务，其工作整个过程如下： 地址解析用客户端浏览器从URL中分解出协议名、主机名、端口、对象路径等部分，需要域名系统DNS解析域名localhost.com,得主机的IP地址。 封装HTTP请求数据包把以上部分结合本机自己的信息，封装成一个HTTP请求数据包 封装成TCP包，建立TCP连接（TCP的三次握手）在HTTP工作开始之前，客户机（Web浏览器）首先要通过网络与服务器建立连接，HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接。 客户机发送请求命令建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可选内容。 服务器响应服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据 服务器关闭TCP连接（TCP的四次挥手）一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码Connection:keep-aliveTCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 附：HTTPS加密原理 URI 的格式是什么？常见的协议有哪些URI是采用一种特定语法标识一个资源的字符串，称之为“统一资源标识符”格式：协议//用户名:密码@授权机构:端口号/路径?查询字符串#哈希例如：ftp://mp3:mp3@ci43198-a.ashvill.nc.home.com:33/VanHalen-Jump.mp3所有其他字符及内容中需用到的定界符也应用%转义（空格%20 /%2F） 常见的协议： 协议 描述 data 链接中直接包含的Base64编码数据 file 本地磁盘的文件 ftp FTP服务器 http 使用超文本传输协议的国际互联网服务器 mailto 电子邮件地址 magnet 可以通过对等网络下载的资源 telnet 与基于Telnet的服务连接 HTTP 协议有几种和服务器交互的方法以HTTP 1.1标准，有如下几种方法： GET：获取资源GET方法用来请求访问已被URL识别的资源 POST：传输实体主体POST方法用来请求服务器传输信息实体的主体 PUT：传输文件PUT要求在请求报文的主体中包含文件内容，然后保存到请求URL指定的位置处于安全考虑，一般web网站不使用此方法，若配合web的安全验证机制，或者架构采用REST标准的网站，就可能开放使用此方法 HEAD：获得报文首部HEAD和GET方法一样，只不过不返回报文主体部分，用于确认URI的有效性及资源更新的日期时间等 DELETE：删除文件DELETE是与PUT相反的方法，是按请求URI删除指定的资源处于安全考虑，一般web网站不使用此方法，若配合web的安全验证机制，或者架构采用REST标准的网站，就可能开放使用此方法 OPTIONS：询问支持的方法用来查询针对请求URI指定的资源支持的方法 TRACE：追踪路径是让web服务器端将之前的请求通信还回给客户端的方法发送请求时，在Max-Frowards首部字段中填入数值，每经过一个服务器端就-1，当数值为0时，停止传输，最后收到服务器返回状态码200 OK的响应但是，这种方法基本很少使用，而且很容易引起XST（跨站追踪）攻击，就更不会用到了。 CONNECT：要求采用隧道协议连接代理该方法要求在于代理服务器通信时建立隧道，实现用隧道协议进行TCP通信，主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经过网络传输。 状态码200，301，304，403,404,500，503分别代表什么意思 200 OK请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码是表示正常状态。 301 Moved Permanently被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。新的永久性的URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。 304 Not Modified如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。该响应必须包含以下的头信息：Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。ETag 和/或 Content-Location，假如同样的请求本应返回200响应。Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。 403 Forbidden服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。 404 Not Found请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。 500 Internal Server Error服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。 503 Service Unavailable由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。 报文有哪几部分组成？ 请求头 首部 主体的的格式和作用 如图所示，为一个完整的请求报文。格式已经在上题中写明，下面列出作用。 HTTP请求头规定了请求的方法，地址，协议版本，本例中使用POST方法请求http://host_name/path地址，协议版本为HTTP1.1。 HTTP首部规定了一个请求的约束和规则，以键值对的形式呈现。本例中的头部键值对分别表达了以下意思： Host: host_name 访问的宿主服务器是host_name Content-Type: text/xml 定义文件接收类型为text/xml格式接收 Content-Length: 18 消息实体的传输长度，压缩后的message-body的长度为18字节 If-Modified-Since: Sat, 02 May 2015 16:17:00 GMT 浏览器最后修改页面缓存的时间，可以让服务器与自己的数据更改时间进行比较 If-None-Match: “03fb33c0bfcc” If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能 Pragma: Public 指定了缓存的规则，本例子中的参数Public意味着可以被任何缓存所缓存 Accept: text/html 浏览器端可以接受的媒体类型，本例中指定为html文档 Accept-Encoding: gzip 指定了代码传输的压缩方式，本例中指定了gzip压缩方式 请求主体的内容由传输者定义，传递了客户端到服务器的内容，其格式可以任意指定。本例中传递了两个键值对。 简述浏览器缓存是如何控制的当浏览器第一次访问服务器请求资源时，服务器会返回资源本体和两条缓存信息（缓存信息以http请求首部的形式定义），分别为Cache-Control和Etag。其中Cache-Control定义了何时缓存过期和缓存的各种存储细节，而Etag则是这个资源的一个特征标识符，只有当资源改变时这个标识符才会改变。当浏览器在此需要这个资源时，先通过检测这个资源的Cache-Control是否已经过期来判断是否需要向服务器发起请求再次索取这个资源，如果没有过期则直接使用缓存资源，如果过期了就连同资源的Etag一起向服务器发送请求索取资源。服务器接收到再次索取资源的请求，比对云端的Etag与请求的Etag是否相等，如果相等，则返回一个304，如果不等，则将新的资源发送给客户端。 下图各个参数是什么意思 用PUT方法请求Request URL地址，请求正常故状态码为200 OK，请求的远程地址（实际IP和端口）是Remote Address。请求TCP链接不要断开，消息实体的传输长度为12个字节，服务器回应的数据格式为json，时间为Date，服务器采用的软件为ngix，框架是Express。客户端请求的数据为任何格式，接受gzip，deflate，sdch编码压缩，只接受中文，对中文的喜好程度是0.8，传输的消息实体的长度为56个字节，传输主体类型为Content-Type，并且设置了cookie，传输的主机和来源站点是note.ruoyu.site，从note.ruoyu.site链接过来，有一些用户信息，传递信息的方式是Ajax。传递的消息主题有一些键值对，其中一个就是article: 若愚@饥人谷]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型链]]></title>
    <url>%2F2018%2F02%2F%E5%8E%9F%E5%9E%8B%E9%93%BE.html</url>
    <content type="text"><![CDATA[我们在写代码时经常会这样写12let arr = [1,2,3]arr.push(4) 那我们就有疑问了，为什么可以这么写？我们通常在刚接触js时，会从各种途径知道，你声明一个数组，如果你想往数组里面加点东西就调用一下arr.push这个方法。那这个方法是从哪儿来的呢？我没有声明这个方法呀 实际上，我们不可能每次定义一个数组的时候就写一个push方法，这样显得太浪费了。js考虑到了这点，它将一些常用的方法如push,forEach等等放在了原型对象上，通过原型链来实现方法的继承。 其实当你这样写的时候：1let arr = [1,2,3] 相当于这样写：1let arr = new Array(1,2,3) 上面一种是对象字面量的写法(数组也是对象)，下面是通过new关键字来实例化一个对象。new后面的是构造函数，等号左边的arr是实例化对象。当你new的时候实际上是发生了这些事情：1.创建一个新对象2.将新对象的proto(隐式原型)属性指向构造函数的prototype(原型对象)3.让构造函数中的this指向新对象，执行构造函数4.判断构造函数的返回值类型然后返回它(如果返回的是值类型，或者没有写返回值，最终会返回创建的新对象；如果有返回值，并且是引用类型就返回这个引用类型的对象)。 简单来说当你用new调用一个函数的时候，会让实例化对象的隐式原型指向构造函数的原型对象。arr.proto = Array.prototype，当你任意创建一个函数的时候原型对象就已经设置好了。 只需要要记住一点，实例化对象的proto指向构造函数的prototype属性，这样就形成了原型链。 当调用实例对象的某个方法时，会检查自身有没有这个方法，如果没有则会顺着原型链一层一层往上找。 这样就可以解释当你用字面量创建一个数组的时候，为什么可以用到数组的push方法。该数组本身并没有数组方法，它调用的是Array.prototype.push方法。 画都有点尴尬，用代码解释一下吧12345arr.__proto__ === Array.prototypeArray.prototype.__proto__ === Object.prototypeObject.prototype.__proto__ === nullArray.__proto__ === Function.PrototypeFunction.prototype.__proto__ === Object.prototype js中的继承就是通过这样一层层的原型链来实现的。 下面是一个实现继承的例子1234567891011121314151617181920212223function Person(name) &#123; this.name = name&#125;Person.prototype.sayHi = function() &#123; console.log('hello')&#125;function Student(name,school) &#123; Person.call(this,name) this.school = school&#125;Student.prototype = Object.create(Person.prototype)Student.prototype.constructor = Student/*或者可以这么写 Object.setPrototypeOf(Student.prototype,Person.prototype)*/Student.prototype.study = function() &#123; console.log('study')&#125;let xiaoming = new Student('xiaoming','qinghua')console.log(xiaoming.name)console.log(xiaoming.school)xiaoming.sayHi()xiaoming.study()]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css常见布局]]></title>
    <url>%2F2018%2F02%2Fcss%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[总结一下目前所知道的常见布局方式 两栏布局，左列定宽，右列自适应该布局方式非常常见，适用于定宽的一侧常为导航，自适应的一侧为内容的布局 使用float+margin实现1234&lt;div class="box"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314.box &#123; height: 100%&#125;.left &#123; width:100px; height:100%; background:red; float:left;&#125;.right &#123; margin-left: 100px; background:green; height:100%;&#125; 使用float+overflow实现1234&lt;div class="box"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314.box &#123; height: 100%&#125;.left &#123; width:100px; height:100%; background:red; float:left;&#125;.right &#123; background:green; height:100%; overflow: hidden;&#125; 使用flex实现123456789101112.box &#123; height: 200px; display:flex;&#125;.left &#123; width: 100px; background: red;&#125;.right &#123; background: green; flex:1;&#125; 两栏布局，右侧宽度固定，左侧宽度自适应使用float+margin实现12345&lt;div class="box"&gt;&lt;!-- 这里要注意写的顺序 --&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314.box &#123; height: 200px;&#125;.left &#123; height:100%; border: 1px solid red; margin-right:100px;&#125;.right &#123; width:100px; height: 100%; border: 1px solid blue; float:right;&#125; 使用定位实现1234&lt;div class="box"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617.box &#123; height: 200px; position: relative;&#125;.left &#123; background: red; height:100%; margin-right:100px;&#125;.right &#123; width:100px; background: blue; position: absolute; height:100%; top:0; right:0;&#125; 使用flex实现1234&lt;div class="box"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112.box &#123; height: 200px; display:flex;&#125;.left &#123; border: 1px solid red; flex:1;&#125;.right &#123; width:100px; border: 1px solid blue;&#125; 两侧定宽，中栏自适应圣杯布局123456&lt;div class="box"&gt; &lt;!--注意顺序--&gt; &lt;div class="middle"&gt;middle&lt;/div&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728.box&#123; padding: 0 100px;/* 留出左右的距离*/ height: 100px; &#125; .box .middle &#123; float: left; width: 100%; height: 100%; background-color: yellow; &#125; .box .left &#123; float: left; width: 100px; margin-left: -100%; background-color: red; position: relative; left: -100px;/*往左拉*/ height: 100%; &#125; .box .right &#123; float: left; width: 100px; margin-left: -100px; background-color: green; position: relative; right: -100px; height:100%; &#125; 双飞翼布局1234567&lt;div class="box"&gt; &lt;div class="middle-wrap"&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div 1234567891011121314151617181920212223242526272829.box &#123; position: relative; height: 100px; &#125; .middle-wrap &#123; position: relative; float: left; width: 100%; height: 100%; &#125; .middle-wrap .middle &#123; height: 100%; margin: 0 100px; /*留出距离*/ background-color: yellow; &#125; .left &#123; float: left; width: 100px; margin-left: -100%; height: 100%; background-color: red; &#125; .right &#123; float: left; width: 100px; height: 100%; margin-left: -100px; background-color: green; &#125; 使用flex实现12345&lt;div class="box"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="middle"&gt;middle&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617.box &#123; border:1px solid; height:100px; display:flex;&#125;.left &#123; background: red; width:100px;&#125;.middle &#123; background: yellow; flex:1&#125;.right &#123; background: blue; width:100px;&#125; 其实css的布局有很多不同的实现方式，这里没办法一下子详尽列完。值得一提的是，都已经2018年了，flex的兼容性也很不错了，像什么float布局早就可以淘汰了，而且float的初衷是用来实现文字环绕效果就不是用来布局的。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件实例间的直接访问]]></title>
    <url>%2F2018%2F01%2F%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E9%97%B4%E7%9A%84%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE.html</url>
    <content type="text"><![CDATA[尽管有 prop 和事件，但是有时仍然需要在 JavaScript 中直接访问子组件。在组件实例中，Vue提供了相应的属性，包括$parent、$children、$refs和$root，这些属性都挂载在组件的this上。 $parent$parent表示父组件的实例，该属性只读。下面是一个简单的例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;div id="app"&gt; &lt;parent-component&gt;&lt;/parent-component&gt;&lt;/div&gt;&lt;template id="parent-component"&gt; &lt;div class="parent"&gt; &lt;h3&gt;我是父组件&lt;/h3&gt; &lt;input type="text" v-model="parentMsg"&gt; &lt;p&gt;&#123;&#123;parentMsg&#125;&#125;&lt;/p&gt; &lt;child-component :msg="parentMsg"&gt;&lt;/child-component&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id="child-component"&gt; &lt;div class="child"&gt; &lt;h3&gt;我是子组件&lt;/h3&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;button @click="showData"&gt;显示父组件的数据&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; Vue.component('parent-component',&#123; template: '#parent-component', data() &#123; return &#123; parentMsg: '我是父组件的数据' &#125; &#125;, components: &#123; 'child-component': &#123; template: '#child-component', data() &#123; return &#123; msg: '' &#125; &#125;, methods: &#123; showData() &#123; this.msg = this.$parent.parentMsg &#125; &#125; &#125; &#125; &#125;) new Vue(&#123; el: '#app' &#125;)&lt;/script&gt; $root$root表示当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己。该属性只读12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;div id="app"&gt; &lt;h3&gt;我是根组件&lt;/h3&gt; &lt;input type="text" v-model="rootMsg"&gt; &lt;p&gt;&#123;&#123;rootMsg&#125;&#125;&lt;/p&gt; &lt;parent-component&gt;&lt;/parent-component&gt;&lt;/div&gt;&lt;template id="parent-component"&gt; &lt;div class="parent"&gt; &lt;h3&gt;我是父组件&lt;/h3&gt; &lt;input type="text" v-model="parentMsg"&gt; &lt;p&gt;&#123;&#123;parentMsg&#125;&#125;&lt;/p&gt; &lt;child-component&gt;&lt;/child-component&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id="child-component"&gt; &lt;div class="child"&gt; &lt;h3&gt;我是子组件&lt;/h3&gt; &lt;br&gt; &lt;button @click="showRootData"&gt;显示根组件数据&lt;/button&gt;&lt;span&gt;&#123;&#123;rootMsg&#125;&#125;&lt;/span&gt; &lt;br&gt; &lt;button @click="showParentData"&gt;显示父组件数据&lt;/button&gt;&lt;span&gt;&#123;&#123;parentMsg&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; Vue.component('parent-component',&#123; template: '#parent-component', data() &#123; return &#123; parentMsg: '我是父组件的数据' &#125; &#125;, components: &#123; 'child-component': &#123; template: '#child-component', data() &#123; return &#123; parentMsg: '', rootMsg: '' &#125; &#125;, methods: &#123; showParentData() &#123; this.parentMsg = this.$parent.parentMsg &#125;, showRootData() &#123; this.rootMsg = this.$root.rootMsg &#125; &#125; &#125; &#125; &#125;) new Vue(&#123; el: '#app', data: &#123; rootMsg: '我是根组件数据' &#125; &#125;)&lt;/script&gt; $children$children表示当前实例的直接子组件。需要注意$children并不保证顺序，也不是响应式的。如果正在尝试使用$children来进行数据绑定，考虑使用一个数组配合v-for来生成子组件，并且使用Array作为真正的来源1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;div id="app"&gt; &lt;parent-component&gt;&lt;/parent-component&gt;&lt;/div&gt;&lt;template id="parent-component"&gt; &lt;div class="parent"&gt; &lt;h3&gt;我是父组件&lt;/h3&gt; &lt;button @click="getData"&gt;获取子组件数据&lt;/button&gt; &lt;br&gt; &lt;div v-html="msg"&gt;&lt;/div&gt; &lt;child-component1&gt;&lt;/child-component1&gt; &lt;child-component2&gt;&lt;/child-component2&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id="child-component1"&gt; &lt;div class="child"&gt; &lt;h3&gt;我是子组件1&lt;/h3&gt; &lt;input type="text" v-model="msg"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id="child-component2"&gt; &lt;div class="child"&gt; &lt;h3&gt;我是子组件2&lt;/h3&gt; &lt;input type="text" v-model="msg"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; Vue.component('parent-component',&#123; template: '#parent-component', data() &#123; return &#123; msg: '' &#125; &#125;, methods: &#123; getData() &#123; let html = '' let children = this.$children for(let i = 0; i &lt; children.length; i++) &#123; html += `&lt;p&gt;$&#123;children[i].msg&#125;&lt;/p&gt;` &#125; this.msg = html &#125; &#125;, components: &#123; 'child-component1': &#123; template: '#child-component1', data() &#123; return &#123; msg: '' &#125; &#125; &#125;, 'child-component2': &#123; template: '#child-component2', data() &#123; return &#123; msg: '' &#125; &#125; &#125; &#125; &#125;) new Vue(&#123; el: '#app' &#125;)&lt;/script&gt; $refs组件个数较多时，难以记住各个组件的顺序和位置，通过序号访问子组件不是很方便在子组件上使用ref属性，可以给子组件指定一个索引ID：12&lt;child-component1 ref="c1"&gt;&lt;/child-component1&gt;&lt;child-component2 ref="c2"&gt;&lt;/child-component2&gt; 在父组件中，则通过$refs.索引ID访问子组件的实例12this.$refs.c1this.$refs.c2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;div id="app"&gt; &lt;parent-component&gt;&lt;/parent-component&gt;&lt;/div&gt;&lt;template id="parent-component"&gt; &lt;div class="parent"&gt; &lt;h3&gt;我是父组件&lt;/h3&gt; &lt;div&gt; &lt;button @click="getData1"&gt;获取子组件c1的数据&lt;/button&gt; &lt;p&gt;&#123;&#123;msg1&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;button @click="getData2"&gt;获取子组件c2的数据&lt;/button&gt; &lt;p&gt;&#123;&#123;msg2&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;child-component1 ref="c1"&gt;&lt;/child-component1&gt; &lt;child-component2 ref="c2"&gt;&lt;/child-component2&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id="child-component1"&gt; &lt;div class="child"&gt; &lt;h3&gt;我是子组件1&lt;/h3&gt; &lt;input type="text" v-model="msg"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id="child-component2"&gt; &lt;div class="child"&gt; &lt;h3&gt;我是子组件2&lt;/h3&gt; &lt;input type="text" v-model="msg"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; Vue.component('parent-component',&#123; template: '#parent-component', data() &#123; return &#123; msg1: '', msg2: '' &#125; &#125;, methods: &#123; getData1() &#123; this.msg1 = this.$refs.c1.msg &#125;, getData2() &#123; this.msg2 = this.$refs.c2.msg &#125; &#125;, components: &#123; 'child-component1': &#123; template: '#child-component1', data() &#123; return &#123; msg: '' &#125; &#125; &#125;, 'child-component2': &#123; template: '#child-component2', data() &#123; return &#123; msg: '' &#125; &#125; &#125; &#125; &#125;) new Vue(&#123; el: '#app' &#125;) &lt;/script&gt; 虽然vue提供了以上方式对组件实例进行直接访问，但并不推荐这么做。这会导致组件间紧密耦合，且自身状态难以理解，所以尽量使用props、自定义事件以及内容分发slot来传递数据]]></content>
      <categories>
        <category>跟着文档学vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态组件]]></title>
    <url>%2F2018%2F01%2F%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6.html</url>
    <content type="text"><![CDATA[让多个组件使用同一个挂载点，并动态切换，这就是动态组件。通过使用保留的 &lt;component&gt; 元素，动态地绑定到它的 is 特性，可以实现动态组件12345678910111213141516171819202122232425262728293031&lt;div id="app"&gt; &lt;button @click="change"&gt;切换页面&lt;/button&gt; &lt;component :is="currentView"&gt;&lt;/component&gt;&lt;/div&gt;&lt;script&gt; let home =&#123;template: '&lt;div&gt;我是主页&lt;/div&gt;'&#125;, post =&#123;template: '&lt;div&gt;我是提交页&lt;/div&gt;'&#125;, archive =&#123;template: '&lt;div&gt;我是存档页&lt;/div&gt;'&#125; new Vue(&#123; el: '#app', components: &#123; home, post, archive &#125;, data: &#123; index: 0, arr: ['home','post','archive'] &#125;, computed: &#123; currentView() &#123; return this.arr[this.index] &#125; &#125;, methods: &#123; change() &#123; this.index = (++this.index) % 3 &#125; &#125; &#125;)&lt;/script&gt; 也可以直接绑定到组件对象上123456789101112131415161718192021222324252627&lt;div id="app"&gt; &lt;button @click="change"&gt;切换页面&lt;/button&gt; &lt;component :is="currentView"&gt;&lt;/component&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; index: 0, arr: [ &#123;template: '&lt;div&gt;我是主页&lt;/div&gt;'&#125;, &#123;template: '&lt;div&gt;我是提交页&lt;/div&gt;'&#125;, &#123;template: '&lt;div&gt;我是存档页&lt;/div&gt;'&#125; ] &#125;, computed: &#123; currentView() &#123; return this.arr[this.index] &#125; &#125;, methods: &#123; change() &#123; this.index = (++this.index) % 3 &#125; &#125; &#125;)&lt;/script&gt; 缓存如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数。&lt;keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 &lt;transition&gt; 相似，&lt;keep-alive&gt; 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中 基础用法123456789101112131415161718192021222324252627282930&lt;div id="app"&gt; &lt;button @click="change"&gt;切换页面&lt;/button&gt; &lt;keep-alive&gt; &lt;component :is="currentView"&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; index: 0, arr: [ &#123;template: '&lt;div&gt;我是主页&lt;/div&gt;'&#125;, &#123;template: '&lt;div&gt;我是提交页&lt;/div&gt;'&#125;, &#123;template: '&lt;div&gt;我是存档页&lt;/div&gt;'&#125; ] &#125;, computed: &#123; currentView() &#123; return this.arr[this.index] &#125; &#125;, methods: &#123; change() &#123; let len = this.arr.length this.index = (++this.index) % len &#125; &#125; &#125;)&lt;/script&gt; 条件判断如果有多个条件性的子元素，&lt;keep-alive&gt; 要求同时只有一个子元素被渲染123456789101112131415161718192021222324252627&lt;div id="app"&gt; &lt;button @click="change"&gt;切换页面&lt;/button&gt; &lt;keep-alive&gt; &lt;home v-if="index===0"&gt;&lt;/home&gt; &lt;post v-else-if="index===1"&gt;&lt;/post&gt; &lt;archive v-else&gt;&lt;/archive&gt; &lt;/keep-alive&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', components: &#123; home: &#123;template: '&lt;div&gt;我是主页&lt;/div&gt;'&#125;, post: &#123;template: '&lt;div&gt;我是提交页&lt;/div&gt;'&#125;, archive: &#123;template: '&lt;div&gt;我是存档页&lt;/div&gt;'&#125; &#125;, data: &#123; index: 0, &#125;, methods: &#123; change() &#123; let len = Object.keys(this.$options.components).length this.index = (++this.index) % len &#125; &#125; &#125;)&lt;/script&gt; 生命周期钩子函数当组件在 &lt;keep-alive&gt; 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 &lt;keep-alive&gt; 树内的所有嵌套组件中触发。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div id="app"&gt; &lt;button @click="change"&gt;切换页面&lt;/button&gt; &lt;keep-alive&gt; &lt;component :is="currentView" @pass-data="getData"&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; index: 0, message: '', arr: [ &#123; template: '&lt;div&gt;我是主页&lt;/div&gt;', activated() &#123; this.$emit('pass-data','主页被添加') &#125;, deactivated() &#123; this.$emit('pass-data','主页被移除') &#125; &#125;, &#123; template: '&lt;div&gt;我是提交页&lt;/div&gt;' &#125;, &#123; template: '&lt;div&gt;我是存档页&lt;/div&gt;' &#125; ] &#125;, computed: &#123; currentView() &#123; return this.arr[this.index] &#125; &#125;, methods: &#123; change() &#123; let len = this.arr.length this.index = (++this.index) % len &#125;, getData(value) &#123; this.message = value setTimeout(() =&gt; &#123; this.message = '' &#125;, 500); &#125; &#125; &#125;)&lt;/script&gt; include and excludeinclude 和 exclude 属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示123456789101112&lt;!-- 逗号分隔字符串 --&gt;&lt;keep-alive include="a,b"&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 正则表达式 (使用 v-bind) --&gt;&lt;keep-alive :include="/a|b/"&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- Array (use v-bind) --&gt;&lt;keep-alive :include="['a', 'b']"&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称（父组件 components 选项的键值）。匿名组件不能被匹配123&lt;keep-alive include="home,archive"&gt; &lt;component :is="currentView"&gt;&lt;/component&gt; &lt;/keep-alive&gt; 上面的代码表示，只缓存home和archive，不缓存post 123456789101112131415161718192021222324252627282930&lt;div id="app"&gt; &lt;button @click="change"&gt;切换页面&lt;/button&gt; &lt;keep-alive include="home,archive"&gt; &lt;component :is="currentView"&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; index: 0, arr: [ &#123;name: 'home',template: '&lt;div&gt;我是主页&lt;/div&gt;'&#125;, &#123;name: 'post',template: '&lt;div&gt;我是提交页&lt;/div&gt;'&#125;, &#123;name: 'archive',template: '&lt;div&gt;我是存档页&lt;/div&gt;'&#125;, ] &#125;, computed: &#123; currentView() &#123; return this.arr[this.index] &#125; &#125;, methods: &#123; change() &#123; let len = this.arr.length this.index = (++this.index) % len &#125; &#125; &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>跟着文档学vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内容分发slot]]></title>
    <url>%2F2018%2F01%2F%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91slot.html</url>
    <content type="text"><![CDATA[为了让组件可以组合，需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为 内容分发 (或 “transclusion” )。Vue实现了一个内容分发 API，参照了当前 Web 组件规范草案，使用特殊的 元素作为原始内容的插槽 编译作用域在深入内容分发 API 之前，先明确内容在哪个作用域里编译。假定模板为123&lt;child-component&gt; &#123;&#123; message &#125;&#125;&lt;/child-component&gt; message 应该绑定到父组件的数据，还是绑定到子组件的数据？答案是父组件。组件作用域简单地说是：父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。 一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法：12&lt;!-- 无效 --&gt;&lt;child-component v-show="someChildProperty"&gt;&lt;/child-component&gt; 假定someChildProperty是子组件的属性，上例不会如预期工作。父组件模板不应该知道子组件的状态如果要绑定作用域内的指令到一个组件的根节点，应当在组件自己的模板上做：123456789Vue.component('child-component', &#123; // 有效，因为是在正确的作用域内 template: '&lt;div v-show="someChildProperty"&gt;Child&lt;/div&gt;', data: function () &#123; return &#123; someChildProperty: true &#125; &#125;&#125;) 默认丢弃一般地，如果子组件模板不包含&lt;slot&gt;插口，父组件的内容将会被丢弃。12345678910111213141516171819202122232425262728293031&lt;div id="app"&gt; &lt;parent&gt;&lt;/parent&gt;&lt;/div&gt;&lt;script&gt; let childNode = &#123; template: ` &lt;div class="child"&gt; &lt;p&gt;子组件&lt;/p&gt; &lt;/div&gt; ` &#125; let parentNode = &#123; template: ` &lt;div class="parent"&gt; &lt;p&gt;父组件&lt;/p&gt; &lt;child&gt; &lt;p&gt;测试内容&lt;/p&gt; &lt;/child&gt; &lt;/div&gt; `, components: &#123; child: childNode &#125; &#125; new Vue(&#123; el: '#app', components: &#123; parent: parentNode &#125; &#125;)&lt;/script&gt; 如下图所示，&lt;child&gt;所包含的&lt;p&gt;测试内容&lt;/p&gt;被丢弃 内联模板如果子组件有 inline-template 特性，组件将把它的内容当作它的模板，而忽略真实的模板内容。但是 inline-template 让模板的作用域难以理解。使用 template 选项在组件内定义模板或者在 .vue 文件中使用 template 元素才是最佳实践。 12345678910111213141516171819202122232425262728293031&lt;div id="app"&gt; &lt;parent&gt;&lt;/parent&gt;&lt;/div&gt;&lt;script&gt; let childNode = &#123; template: ` &lt;div class="child"&gt; &lt;p&gt;子组件&lt;/p&gt; &lt;/div&gt; ` &#125; let parentNode = &#123; template: ` &lt;div class="parent"&gt; &lt;p&gt;父组件&lt;/p&gt; &lt;child inline-template&gt; &lt;p&gt;测试内容&lt;/p&gt; &lt;/child&gt; &lt;/div&gt; `, components: &#123; child: childNode &#125; &#125; new Vue(&#123; el: '#app', components: &#123; parent: parentNode &#125; &#125;)&lt;/script&gt; 匿名插槽当子组件模板只有一个没有属性的 slot 时，父组件整个内容片段将插入到 slot 所在的 DOM 位置，并替换掉 slot 标签本身。1234567891011121314151617181920212223242526272829303132&lt;div id="app"&gt; &lt;parent&gt;&lt;/parent&gt;&lt;/div&gt;&lt;script&gt; let childNode = &#123; template: ` &lt;div class="child"&gt; &lt;p&gt;子组件&lt;/p&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; ` &#125; let parentNode = &#123; template: ` &lt;div class="parent"&gt; &lt;p&gt;父组件&lt;/p&gt; &lt;child&gt; &lt;p&gt;测试内容&lt;/p&gt; &lt;/child&gt; &lt;/div&gt; `, components: &#123; child: childNode &#125; &#125; new Vue(&#123; el: '#app', components: &#123; parent: parentNode &#125; &#125;)&lt;/script&gt; 如果出现多余1个的匿名插槽，vue则会报错12345678910let childNode = &#123; template: ` &lt;div class="child"&gt; &lt;p&gt;子组件&lt;/p&gt; &lt;slot&gt;&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; `&#125; 默认值最初在 &lt;slot&gt; 标签中的任何内容都被视为备用内容，或者称为默认值。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。 当slot存在默认值，且父元素在&lt;child&gt;中没有要插入的内容时，显示默认值12345678910111213141516171819let childNode = &#123; template: ` &lt;div class="child"&gt; &lt;p&gt;子组件&lt;/p&gt; &lt;slot&gt;&lt;p&gt;我是默认值&lt;/p&gt;&lt;/slot&gt; &lt;/div&gt; `&#125;let parentNode = &#123; template: ` &lt;div class="parent"&gt; &lt;p&gt;父组件&lt;/p&gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt; `, components: &#123; child: childNode &#125;&#125; 当slot存在默认值，且父元素在&lt;child&gt;中存在要插入的内容时，则显示设置值123456789101112131415161718192021let childNode = &#123; template: ` &lt;div class="child"&gt; &lt;p&gt;子组件&lt;/p&gt; &lt;slot&gt;&lt;p&gt;我是默认值&lt;/p&gt;&lt;/slot&gt; &lt;/div&gt; `&#125;let parentNode = &#123; template: ` &lt;div class="parent"&gt; &lt;p&gt;父组件&lt;/p&gt; &lt;child&gt; &lt;p&gt;我是设置值&lt;/p&gt; &lt;/child&gt; &lt;/div&gt; `, components: &#123; child: childNode &#125;&#125; 具名插槽&lt;slot&gt; 元素可以用一个特殊的属性 name 来配置如何分发内容。多个 slot 可以有不同的名字。具名 slot 将匹配内容片段中有对应 slot 特性的元素123456789101112131415161718192021222324let childNode = &#123; template: ` &lt;div class="child"&gt; &lt;p&gt;子组件&lt;/p&gt; &lt;slot name="my-header"&gt;头部默认值&lt;/slot&gt; &lt;slot name="my-body"&gt;主体默认值&lt;/slot&gt; &lt;slot name="my-footer"&gt;尾部默认值&lt;/slot&gt; &lt;/div&gt; `&#125;let parentNode = &#123; template: ` &lt;div class="parent"&gt; &lt;p&gt;父组件&lt;/p&gt; &lt;child&gt; &lt;p slot="my-header"&gt;我是头部&lt;/p&gt; &lt;p slot="my-footer"&gt;我是尾部&lt;/p&gt; &lt;/child&gt; &lt;/div&gt; `, components: &#123; child: childNode &#125;&#125; &lt;slot name=&quot;my-body&quot;&gt;主体默认值&lt;/slot&gt;是一个具名插槽，但是在&lt;child&gt;中找不到匹配的片段，该具名插槽作为默认值被渲染出来。 仍然可以有一个匿名 slot，它是默认 slot，作为找不到匹配的内容片段的备用插槽。匿名slot只能作为没有slot属性的元素的插槽，有slot属性的元素如果没有配置slot，则会被抛弃 123456789101112131415161718192021222324let childNode = &#123; template: ` &lt;div class="child"&gt; &lt;p&gt;子组件&lt;/p&gt; &lt;slot name="my-body"&gt;主体默认值&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; `&#125;let parentNode = &#123; template: ` &lt;div class="parent"&gt; &lt;p&gt;父组件&lt;/p&gt; &lt;child&gt; &lt;p slot="my-body"&gt;我是主体&lt;/p&gt; &lt;p&gt;我是其他内容&lt;/p&gt; &lt;p slot="my-footer"&gt;我是尾部&lt;/p&gt; &lt;/child&gt; &lt;/div&gt; `, components: &#123; child: childNode &#125;&#125; 作用域插槽作用域插槽是一种特殊类型的插槽，用作一个 (能被传递数据的) 可重用模板，来代替已经渲染好的元素。 在子组件中，只需将数据传递到插槽，就像你将 prop 传递给组件一样：123&lt;div class="child"&gt; &lt;slot text="hello from child"&gt;&lt;/slot&gt;&lt;/div&gt; 在父级中，具有特殊特性 slot-scope 的 &lt;template&gt; 元素必须存在，表示它是作用域插槽的模板。在 2.5.0+，slot-scope 能被用在任意元素或组件中而不再局限于 &lt;template&gt;。slot-scope 的值将被用作一个临时变量名，此变量接收从子组件传递过来的 prop 对象：12345678&lt;div class="parent"&gt; &lt;child&gt; &lt;template slot-scope="props"&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/child&gt;&lt;/div&gt; 例：1234567891011121314151617181920212223242526272829303132333435&lt;div id="app"&gt; &lt;parent&gt;&lt;/parent&gt;&lt;/div&gt;&lt;script&gt; let childNode = &#123; template: ` &lt;div class="child"&gt; &lt;p&gt;子组件&lt;/p&gt; &lt;slot xxx="hello from child"&gt;&lt;/slot&gt; &lt;/div&gt; ` &#125; let parentNode = &#123; template: ` &lt;div class="parent"&gt; &lt;p&gt;父组件&lt;/p&gt; &lt;child&gt; &lt;template slot-scope="props"&gt; &lt;p&gt;hello from parent&lt;/p&gt; &lt;p&gt;&#123;&#123;props.xxx&#125;&#125;&lt;/p&gt; &lt;/template&gt; &lt;/child&gt; &lt;/div&gt; `, components: &#123; child: childNode &#125; &#125; new Vue(&#123; el: '#app', components: &#123; parent: parentNode &#125; &#125;)&lt;/script&gt; 渲染结果为： 作用域插槽更具代表性的用例是列表组件，允许组件自定义应该如何渲染列表每一项。123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div id="app"&gt; &lt;parent&gt;&lt;/parent&gt;&lt;/div&gt;&lt;script&gt; let childNode = &#123; template: ` &lt;ul&gt; &lt;slot name="item" v-for="item of items" :text="item.text"&gt;&lt;/slot&gt; &lt;/ul&gt; `, data() &#123; return &#123; items: [ &#123;id: 1,text: '选项1'&#125;, &#123;id: 2,text: '选项2'&#125;, &#123;id: 3,text: '选项3'&#125;, ] &#125; &#125; &#125; let parentNode = &#123; template: ` &lt;div class="parent"&gt; &lt;p&gt;父组件&lt;/p&gt; &lt;child&gt; &lt;template slot="item" slot-scope="props"&gt; &lt;li&gt;&#123;&#123;props.text&#125;&#125;&lt;/li&gt; &lt;/template&gt; &lt;/child&gt; &lt;/div&gt; `, components: &#123; child: childNode &#125; &#125; new Vue(&#123; el: '#app', components: &#123; parent: parentNode &#125; &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>跟着文档学vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义事件]]></title>
    <url>%2F2018%2F01%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6.html</url>
    <content type="text"><![CDATA[我们知道，父组件使用 prop 传递数据给子组件。但子组件怎么跟父组件通信呢？这个时候 Vue 的自定义事件系统就派得上用场了。 事件绑定每个 Vue 实例都实现了事件接口，即： 使用 $on(eventName) 监听事件 使用 $emit(eventName) 触发事件 注意：Vue 的事件系统与浏览器的 EventTarget API 有所不同。尽管它们的运行起来类似，但是 $on 和 $emit 并不是addEventListener 和 dispatchEvent 的别名。 另外，父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。 注意：不能用 $on 侦听子组件释放的事件，而必须在模板里直接用 v-on 绑定，参见下面的例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div id="app"&gt; &lt;parent&gt;&lt;/parent&gt;&lt;/div&gt;&lt;script&gt; let childNode = &#123; template: '&lt;button @click="incrementCounter"&gt;&#123;&#123;counter&#125;&#125;&lt;/button&gt;', data() &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; incrementCounter() &#123; this.counter += 1 this.$emit('increment') &#125; &#125; &#125; let parentNode = &#123; template: ` &lt;div class="parent"&gt; &lt;p&gt;&#123;&#123;total&#125;&#125;&lt;/p&gt; &lt;child @increment="incrementTotal"&gt;&lt;/child&gt; &lt;child @increment="incrementTotal"&gt;&lt;/child&gt; &lt;/div&gt; `, components: &#123; child: childNode &#125;, data() &#123; return &#123; total: 0 &#125; &#125;, methods: &#123; incrementTotal() &#123; this.total += 1 &#125; &#125; &#125; new Vue(&#123; el: '#app', components: &#123; parent: parentNode &#125; &#125;)&lt;/script&gt; .sync修饰符在一些情况下，可能会需要对一个 prop 进行双向绑定。事实上，这正是Vue1.x中的 .sync修饰符所提供的功能。当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定的值。这很方便，但也会导致问题，因为它破坏了单向数据流的假设。由于子组件改变 prop 的代码和普通的状态改动代码毫无区别，当光看子组件的代码时，完全不知道它何时悄悄地改变了父组件的状态。这在 debug 复杂结构的应用时会带来很高的维护成本，上面所说的正是在 2.0 中移除 .sync 的理由。从 2.3.0 起重新引入了 .sync 修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 侦听器1&lt;comp :foo.sync="bar"&gt;&lt;/comp&gt; 会被扩展为：1&lt;comp :foo="bar" @update:foo="val =&gt; bar = val"&gt;&lt;/comp&gt; 当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：1this.$emit('update:foo', newValue) 例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div id="app"&gt; &lt;parent&gt;&lt;/parent&gt;&lt;/div&gt;&lt;script&gt; let childNode = &#123; template: ` &lt;div class="child"&gt; &lt;div&gt;子组件数据：&#123;&#123;childMsg&#125;&#125;&lt;/div&gt; &lt;input v-model.number="childMsg"&gt; &lt;button @click="add"&gt;+1&lt;/button&gt; &lt;/div&gt; `, data() &#123; return &#123; childMsg: 0 &#125; &#125;, methods: &#123; add() &#123; this.childMsg += 1 this.$emit('update:foo',this.childMsg) &#125; &#125; &#125; let parentNode = &#123; template: ` &lt;div class="parent"&gt; &lt;p&gt;父组件数据：&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;child :foo.sync="msg"&gt;&lt;/child&gt; &lt;/div&gt; `, components: &#123; child: childNode &#125;, data() &#123; return &#123; msg: 0 &#125; &#125; &#125; new Vue(&#123; el: '#app', components: &#123; parent: parentNode &#125; &#125;)&lt;/script&gt; 使用自定义事件的表单输入组件自定义事件可以用来创建自定义的表单输入组件，使用 v-model 来进行数据双向绑定。要牢记：1&lt;input v-model="something"&gt; 这不过是以下示例的语法糖：123&lt;input v-bind:value="something" v-on:input="something = $event.target.value"&gt; 所以在组件中使用时，它相当于下面的简写：1234&lt;custom-input v-bind:value="something" v-on:input="something = arguments[0]"&gt;&lt;/custom-input&gt; 所以要让组件的 v-model 生效，它应该 (从 2.2.0 起是可配置的)： 接受一个 value prop 在有新的值时触发 input 事件并将新值作为参数 例：1234567891011121314151617181920212223242526272829&lt;div id="app"&gt; &lt;parent v-model="message"&gt;&lt;/parent&gt; &lt;!-- 上面的代码等价于下面的代码;':value'就是传递到组件中的prop值 --&gt; &lt;!-- &lt;parent :value="message" @input="message = arguments[0]"&gt;&lt;/parent&gt; --&gt;&lt;/div&gt;&lt;script src="../vue.js"&gt;&lt;/script&gt;&lt;script&gt; Vue.component('parent',&#123; template: ` &lt;div class="parent"&gt; &lt;input :value="value" @input="onInput"&gt; &lt;p&gt;父组件的内容是：&#123;&#123;value&#125;&#125;&lt;/p&gt; &lt;/div&gt; `, props: ['value'], methods: &#123; onInput() &#123; // event.target.value就是上面代码中的arguments[0] this.$emit('input',event.target.value) &#125; &#125; &#125;) new Vue(&#123; el: '#app', data: &#123; message: 'hello' &#125; &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>跟着文档学vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件选项props]]></title>
    <url>%2F2018%2F01%2F%E7%BB%84%E4%BB%B6%E9%80%89%E9%A1%B9props.html</url>
    <content type="text"><![CDATA[组件接受的选项大部分与Vue实例一样，而选项props是组件中非常重要的一个选项。在 Vue 中，父子组件的关系可以总结为 props down, events up。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息 父子级组件在一个良好定义的接口中尽可能将父子组件解耦是很重要的。这保证了每个组件可以在相对隔离的环境中书写和理解，也大幅提高了组件的可维护性和可重用性。 [错误写法]下面这种形式的写法是错误的，因为当子组件注册到父组件时，Vue.js会编译好父组件的模板，模板的内容已经决定了父组件将要渲染的HTML。&lt;parent&gt;...&lt;/parent&gt;运行时，它的一些子标签只会被当作普通的HTML来执行，&lt;child&gt;&lt;/child&gt;不是标准的HTML标签，会被浏览器直接忽视掉123456&lt;div id="app"&gt; &lt;parent&gt; &lt;child&gt;&lt;/child&gt; &lt;child&gt;&lt;/child&gt; &lt;/parent&gt;&lt;/div&gt; 在父组件标签之外使用子组件也是错误的1234&lt;div id="app"&gt; &lt;parent&gt;&lt;/parent&gt; &lt;child&gt;&lt;/child&gt;&lt;/div&gt; [正确写法]12345678910111213141516171819202122232425&lt;div id="app"&gt; &lt;parent&gt;&lt;/parent&gt;&lt;/div&gt;&lt;script&gt; let childNode = &#123; template: '&lt;div&gt;childNode&lt;/div&gt;' &#125; let parentNode = &#123; template: ` &lt;div class="parent"&gt; &lt;child&gt;&lt;/child&gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt; `, components: &#123; 'child': childNode &#125; &#125; new Vue(&#123; el: '#app', components: &#123; 'parent': parentNode &#125; &#125;)&lt;/script&gt; 静态props组件实例的作用域是孤立的。这意味着不能 (也不应该) 在子组件的模板内直接引用父组件的数据。要让子组件使用父组件的数据，需要通过子组件的 props 选项。 子组件要显式地用 props 选项声明它期待获得的数据。静态Prop通过为子组件在父组件中的占位符添加特性的方式来达到传值的目的1234567891011121314151617181920212223242526 &lt;div id="app"&gt; &lt;parent&gt;&lt;/parent&gt;&lt;/div&gt;&lt;script&gt; let childNode = &#123; template: '&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;', props: ['message'] &#125; let parentNode = &#123; template: ` &lt;div class="parent"&gt; &lt;child message="aaa"&gt;&lt;/child&gt; &lt;child message="bbb"&gt;&lt;/child&gt; &lt;/div&gt; `, components: &#123; 'child': childNode &#125; &#125; new Vue(&#123; el: '#app', components: &#123; 'parent': parentNode &#125; &#125;)&lt;/script&gt; 动态props在模板中，要动态地绑定父组件的数据到子模板的 props，与绑定到任何普通的HTML特性相类似，就是用 v-bind。每当父组件的数据变化时，该变化也会传导给子组件。1234567891011121314151617181920212223242526272829303132&lt;div id="app"&gt; &lt;parent&gt;&lt;/parent&gt;&lt;/div&gt;&lt;script&gt; let childNode = &#123; template: '&lt;div&gt;&#123;&#123;myMessage&#125;&#125;&lt;/div&gt;', props: ['myMessage'] &#125; let parentNode = &#123; template: ` &lt;div class="parent"&gt; &lt;child :my-message="data1"&gt;&lt;/child&gt; &lt;child :my-message="data2"&gt;&lt;/child&gt; &lt;/div&gt; `, components: &#123; 'child': childNode &#125;, data() &#123; return &#123; 'data1': 'aaa', 'data2': 'bbb', &#125; &#125; &#125; new Vue(&#123; el: '#app', components: &#123; 'parent': parentNode &#125; &#125;)&lt;/script&gt; props验证可以为组件的 props 指定验证规格。如果传入的数据不符合规格，Vue会发出警告。当组件给其他人使用时，这很有用。要指定验证规格，需要用对象的形式，而不能用字符串数组：12345678910111213141516171819202122232425262728293031Vue.component('example', &#123; props: &#123; // 基础类型检测 (`null` 意思是任何类型都可以) propA: Number, // 多种类型 propB: [String, Number], // 必传且是字符串 propC: &#123; type: String, required: true &#125;, // 数字，有默认值 propD: &#123; type: Number, default: 100 &#125;, // 数组/对象的默认值应当由一个工厂函数返回 propE: &#123; type: Object, default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125; &#125;&#125;) type 可以是下面原生构造器： String Number Boolean Function Object Array Symbol type 也可以是一个自定义构造器函数，使用 instanceof 检测。当 prop 验证失败，Vue 会抛出警告 (如果使用的是开发版本)。注意 prop 会在组件实例创建之前进行校验，所以在 default 或 validator 函数里，诸如 data、computed 或 methods 等实例属性还无法使用。下面是一个简单的例子，如果传入子组件的message不是数字，则抛出警告：1234567891011121314151617181920212223242526272829303132&lt;div id="app"&gt; &lt;parent&gt;&lt;/parent&gt;&lt;/div&gt;&lt;script&gt; let childNode = &#123; template: '&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;', props: &#123; message: Number &#125; &#125; let parentNode = &#123; template: ` &lt;div class="parent"&gt; &lt;child :message="msg"&gt;&lt;/child&gt; &lt;/div&gt; `, components: &#123; 'child': childNode &#125;, data() &#123; return &#123; msg: '123' &#125; &#125; &#125; new Vue(&#123; el: '#app', components: &#123; 'parent': parentNode &#125; &#125;)&lt;/script&gt; 如果传入的msg是数字123时，则没有警告。传入字符串’123’时，则抛出警告 可自定义验证函数，但函数返回false时，则抛出警告。将上面的代码中子组件的内容修改如下：12345678910let childNode = &#123; template: '&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;', props: &#123; message: &#123; validator(value) &#123; return value &gt; 10 &#125; &#125; &#125;&#125; 如果父组件传入msg的值小于10，则抛出警告123456789101112131415let parentNode = &#123; template: ` &lt;div class="parent"&gt; &lt;child :message="msg"&gt;&lt;/child&gt; &lt;/div&gt; `, components: &#123; 'child': childNode &#125;, data() &#123; return &#123; msg: 1 &#125; &#125;&#125; 单项数据流prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着不应该在子组件内部改变 prop。如果这么做了，Vue 会在控制台给出警告。下面是一个典型的例子12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id="app"&gt; &lt;parent&gt;&lt;/parent&gt;&lt;/div&gt;&lt;script&gt; let childNode = &#123; template: ` &lt;div class="child"&gt; &lt;div&gt; &lt;span&gt;子组件数据&lt;/span&gt; &lt;input v-model="childMsg"&gt; &lt;/div&gt; &lt;p&gt;&#123;&#123;childMsg&#125;&#125;&lt;/p&gt; &lt;/div&gt; `, props: ['childMsg'] &#125; let parentNode = &#123; template: ` &lt;div class="parent"&gt; &lt;div&gt; &lt;span&gt;父组件数据&lt;/span&gt; &lt;input v-model="msg"&gt; &lt;/div&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;child :child-msg="msg"&gt;&lt;/child&gt; &lt;/div&gt; `, components: &#123; child: childNode &#125;, data() &#123; return &#123; msg: '' &#125; &#125; &#125; new Vue(&#123; el: '#app', components: &#123; parent: parentNode &#125; &#125;)&lt;/script&gt; 当修改子组件的数据时，浏览器会抛出下图所示警告 修改prop数据修改prop中的数据通常有以下两种原因：1.prop 作为初始值传入后，子组件想把它当作局部数据来用2.prop 作为初始值传入，由子组件处理成其它数据输出注意：JS中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。 对于这两种情况，正确的应对方式是1.定义一个全局变量，并用prop的值初始化它。但是，定义的局部变量counter只能接受initialCounter的初始值，当父组件要传递的值发生变化时，counter无法接收到最新值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div id="app"&gt; &lt;parent&gt;&lt;/parent&gt;&lt;/div&gt;&lt;script&gt; let childNode = &#123; template: ` &lt;div class="child"&gt; &lt;div&gt; &lt;span&gt;子组件数据&lt;/span&gt; &lt;input v-model="temp"&gt; &lt;/div&gt; &lt;p&gt;&#123;&#123;temp&#125;&#125;&lt;/p&gt; &lt;/div&gt; `, props: ['childMsg'], data() &#123; return &#123; temp: this.childMsg &#125; &#125; &#125; let parentNode = &#123; template: ` &lt;div class="parent"&gt; &lt;div&gt; &lt;span&gt;父组件数据&lt;/span&gt; &lt;input v-model="msg"&gt; &lt;/div&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;child :child-msg="msg"&gt;&lt;/child&gt; &lt;/div&gt; `, components: &#123; child: childNode &#125;, data() &#123; return &#123; msg: 'hello world' &#125; &#125; &#125; new Vue(&#123; el: '#app', components: &#123; parent: parentNode &#125; &#125;)&lt;/script&gt; 2.定义一个计算属性，处理 prop 的值并返回。但是，由于是计算属性，则只能显示值，而不能设置值。把上面代码中的子组件内容改为如下：1234567891011121314151617let childNode = &#123; template: ` &lt;div class="child"&gt; &lt;div&gt; &lt;span&gt;子组件数据&lt;/span&gt; &lt;input v-model="temp"&gt; &lt;/div&gt; &lt;p&gt;&#123;&#123;temp&#125;&#125;&lt;/p&gt; &lt;/div&gt; `, props: ['childMsg'], computed: &#123; temp() &#123; return this.childMsg &#125; &#125; &#125; 3.更加妥帖的方案是，使用变量储存prop的初始值，并使用watch来观察prop的值的变化。发生变化时，更新变量的值把上面代码改为：12345678910111213141516171819202122let childNode = &#123; template: ` &lt;div class="child"&gt; &lt;div&gt; &lt;span&gt;子组件数据&lt;/span&gt; &lt;input v-model="temp"&gt; &lt;/div&gt; &lt;p&gt;&#123;&#123;temp&#125;&#125;&lt;/p&gt; &lt;/div&gt; `, props: ['childMsg'], data() &#123; return &#123; temp: this.childMsg &#125; &#125;, watch: &#123; childMsg() &#123; this.temp = this.childMsg &#125; &#125;&#125;]]></content>
      <categories>
        <category>跟着文档学vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件的基础用法]]></title>
    <url>%2F2018%2F01%2F%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95.html</url>
    <content type="text"><![CDATA[在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例组件是一个自定义元素或称为一个模块，包括所需的模板、逻辑和样式。在HTML模板中，组件以一个自定义标签的形式存在，起到占位符的功能。通过Vue.js的声明式渲染后，占位符将会被替换为实际的内容 注册组件组件注册包括全局注册和局部注册两种 全局注册要注册一个全局组件，可以使用 Vue.component(tagName, options)123Vue.component('my-component',&#123; &lt;!-- 选项 --&gt;&#125;) 组件在注册之后，便可以在父实例的模块中以自定义元素 &lt;my-component&gt;&lt;/my-component&gt; 的形式使用注意：要确保在初始化根实例之前注册了组件12345678910111213&lt;div id="app"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; // 注册 Vue.component('my-component',&#123; template: '&lt;div&gt;A custom component&lt;/div&gt;' &#125;) // 创建根实例 new Vue(&#123; el: '#app', &#125;)&lt;/script&gt; 渲染结果如下： 局部注册通过使用组件实例选项components注册，可以使组件仅在另一个实例/组件的作用域中可用1234567891011// 注册 let Child = &#123; template: '&lt;div&gt;A custom component&lt;/div&gt;' &#125; // 创建根实例 new Vue(&#123; el: '#app', components: &#123; 'my-component': Child &#125; &#125;) 组件树使用组件实例选项components注册，可以实现组件树的效果12345678910111213141516171819202122232425262728293031&lt;div id="app"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; // 注册 let headerTitle = &#123; template: '&lt;p&gt;我是标题&lt;/p&gt;' &#125; let headerContent = &#123; template: '&lt;p&gt;我是内容&lt;/p&gt;' &#125; let header = &#123; template: ` &lt;div class="hd"&gt; &lt;header-title&gt;&lt;/header-title&gt; &lt;header-content&gt;&lt;/header-content&gt; &lt;/div&gt; `, components: &#123; 'header-title': headerTitle, 'header-content': headerContent &#125; &#125; // 创建根实例 new Vue(&#123; el: '#app', components: &#123; 'my-component': header &#125; &#125;)&lt;/script&gt; 结果： 对于大型应用来说，有必要将整个应用程序划分为组件，以使开发可管理。一般地组件应用模板如下所示1234567&lt;div id="app"&gt; &lt;app-nav&gt;&lt;/app-nav&gt; &lt;app-view&gt; &lt;app-sidebar&gt;&lt;/app-sidebar&gt; &lt;app-content&gt;&lt;/app-content&gt; &lt;/app-view&gt;&lt;/div&gt; [v-once]尽管在 Vue 中渲染 HTML 很快，不过当组件中包含大量静态内容时，可以考虑使用 v-once 将渲染结果缓存起来123Vue.component('my-component', &#123; template: '&lt;div v-once&gt;hello world!...&lt;/div&gt;'&#125;) 模板分离在组件注册中，使用template选项中拼接HTML元素比较麻烦，这也导致了HTML和JS的高耦合性。庆幸的是，Vue.js提供了两种方式将定义在JS中的HTML模板分离出来 使用script标签在script标签里使用 text/x-template 类型，并且指定一个id1234567&lt;script type="text/x-template" id="hello-world-template"&gt; &lt;p&gt;Hello hello hello&lt;/p&gt;&lt;/script&gt;Vue.component('hello-world',&#123; template: '#hello-world-template'&#125;) 上面的代码等价于：123Vue.component('hello-world',&#123; template: '&lt;p&gt;Hello hello hello&lt;/p&gt;'&#125;) 例：1234567891011121314&lt;div id="app"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script type="text/x-template" id="xxx"&gt; &lt;div&gt;hello world&lt;/div&gt;&lt;/script&gt;&lt;script&gt; Vue.component('my-component',&#123; template: '#xxx' &#125;) new Vue(&#123; el: '#app', &#125;)&lt;/script&gt; 结果如下： 使用template标签1234567891011121314&lt;div id="app"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;template id="xxx"&gt; &lt;div&gt;hello world&lt;/div&gt;&lt;/template&gt;&lt;script&gt; Vue.component('my-component',&#123; template: '#xxx' &#125;) new Vue(&#123; el: '#app', &#125;)&lt;/script&gt; 命名约定对于组件的命名，W3C规范是字母小写且包含一个中划线(-)，虽然Vue没有强制要求，但最好遵循规范 1234&lt;!-- 在HTML模版中始终使用 kebab-case --&gt;&lt;kebab-cased-component&gt;&lt;/kebab-cased-component&gt;&lt;camel-cased-component&gt;&lt;/camel-cased-component&gt;&lt;pascal-cased-component&gt;&lt;/pascal-cased-component&gt; 当注册组件时，使用中划线、小驼峰、大驼峰这三种任意一种都可以123456789// 在组件定义中components: &#123; // 使用 中划线 形式注册 'kebab-cased-component': &#123; /* ... */ &#125;, // 使用 小驼峰 形式注册 'camelCasedComponent': &#123; /* ... */ &#125;, // 使用 大驼峰 形式注册 'PascalCasedComponent': &#123; /* ... */ &#125;&#125; 嵌套限制并不是所有的元素都可以嵌套模板，因为要受到HTML元素嵌套规则的限制，尤其像&lt;ul&gt;，&lt;ol&gt;，&lt;table&gt;，&lt;select&gt; 限制了能被它包裹的元素，而一些像 &lt;option&gt; 这样的元素只能出现在某些其它元素内部 在自定义组件中使用这些受限制的元素时会导致一些问题，例如：1234567891011121314&lt;table id="app"&gt; &lt;my-row&gt;&lt;/my-row&gt;&lt;/table&gt;&lt;script&gt; let header = &#123; template: '&lt;div class="hd"&gt;我是标题&lt;/div&gt;' &#125; new Vue(&#123; el: '#app', components: &#123; 'my-row': header &#125; &#125;)&lt;/script&gt; 渲染失败：自定义组件 &lt;my-row&gt; 会被当作无效的内容，因此会导致错误的渲染结果。变通的方案是使用特殊的 is 特性：12&lt;!-- &lt;my-row&gt;&lt;/my-row&gt; --&gt;&lt;tr is="my-row"&gt;&lt;/tr&gt; 注意：如果使用来自以下来源之一的字符串模板，则没有这些限制： &lt;script type=&quot;text/x-template&quot;&gt; JavaScript 内联模板字符串 .vue组件 根元素Vue强制要求每一个Vue实例(组件本质上就是一个Vue实例)需要有一个根元素错误示范：1234567891011121314&lt;div id="app"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component', &#123; template: ` &lt;p&gt;第一段&lt;/p&gt; &lt;p&gt;第二段&lt;/p&gt; `, &#125;) new Vue(&#123; el: '#app' &#125;)&lt;/script&gt; 报错：- Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead. 解决办法：12345678Vue.component('my-component', &#123; template: ` &lt;div&gt; &lt;p&gt;第一段&lt;/p&gt; &lt;p&gt;第二段&lt;/p&gt; &lt;/div&gt; `, &#125;) data数据一般地，我们在Vue实例对象或Vue组件对象中，我们通过data来传递数据1234567891011121314&lt;div id="app"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component', &#123; template: '&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;', data: &#123; message: 'hello' &#125; &#125;) new Vue(&#123; el: '#app' &#125;)&lt;/script&gt; 上面代码会报错，并在控制台发出错误提示，告诉你在组件中 data 必须是一个函数。让我们先来做个弊解决它1234567891011121314151617&lt;div id="app"&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; let data = &#123;counter: 0&#125; Vue.component('my-component', &#123; template: '&lt;button @click="counter += 1"&gt;&#123;&#123;counter&#125;&#125;&lt;/button&gt;', data()&#123; return data &#125; &#125;) new Vue(&#123; el: '#app' &#125;)&lt;/script&gt; 结果如下：由于这三个组件共享了同一个 data，因此增加一个 counter 会影响所有组件 当一个组件被定义， data 需要声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象。通过提供 data 函数，每次创建一个新实例后，能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。因此，可以通过为每个组件返回全新的 data 对象来解决这个问题：12345678Vue.component('my-component', &#123; template: '&lt;button @click="counter += 1"&gt;&#123;&#123;counter&#125;&#125;&lt;/button&gt;', data()&#123; return &#123; counter: 0 &#125; &#125; &#125;) 结果如下： 原生事件有时候，可能想在某个组件的根元素上监听一个原生事件。直接使用v-on指令是不生效的1234567891011121314151617181920 &lt;div id="app"&gt; &lt;my-component @click="fn"&gt;&lt;/my-component&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component', &#123; template: '&lt;button&gt;click me&lt;/button&gt;' &#125;) new Vue(&#123; el: '#app', data: &#123; message: 0 &#125;, methods: &#123; fn() &#123; this.message += 1 &#125; &#125; &#125;)&lt;/script&gt; 可以使用 .native 修饰 v-on指令即可1&lt;my-component @click.native="fn"&gt;&lt;/my-component&gt;]]></content>
      <categories>
        <category>跟着文档学vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表单输入绑定]]></title>
    <url>%2F2018%2F01%2F%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A.html</url>
    <content type="text"><![CDATA[基础用法可以用 v-model 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。v-model本质上不过是语法糖，它负责监听用户的输入事件以更新数据。注意：v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。应该通过 JavaScript 在组件的 data 选项中声明初始值。 文本123456789101112&lt;div id="app"&gt; &lt;input type="text" v-model="message"&gt; &lt;p&gt;Message is: &#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; message: '' &#125; &#125;)&lt;/script&gt; 结果：实际上v-model是:value和@input事件的语法糖上面的代码实际上等于这样：123456789101112&lt;div id="app"&gt; &lt;input type="text" :value="message" @input="message = $event.target.value"&gt; &lt;p&gt;Message is: &#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; message: '' &#125; &#125;)&lt;/script&gt; 多行文本123&lt;span&gt;Multiline message is:&lt;/span&gt;&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;textarea v-model="message" placeholder="add multiple lines"&gt;&lt;/textarea&gt; 注意：在文本区域插值 &lt;textarea&gt;&lt;/textarea&gt; 并不会生效，应用 v-model 来代替 复选框123456789101112&lt;div id="app"&gt; &lt;input type="checkbox" id="xxx" v-model="checked"&gt; &lt;label for="xxx"&gt;&#123;&#123;checked&#125;&#125;&lt;/label&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; checked: false &#125; &#125;)&lt;/script&gt; 多个复选框，绑定到同一个数组123456789101112131415161718192021&lt;div id="app"&gt; &lt;div&gt; &lt;input type="checkbox" id="jack" v-model="checkedNames" value="jack"&gt; &lt;label for="jack"&gt;jack&lt;/label&gt; &lt;input type="checkbox" id="john" v-model="checkedNames" value="john"&gt; &lt;label for="john"&gt;john&lt;/label&gt; &lt;input type="checkbox" id="mike" v-model="checkedNames" value="mike"&gt; &lt;label for="mike"&gt;mike&lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;checkedName is: &#123;&#123;checkedNames&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; checkedNames: [] &#125; &#125;)&lt;/script&gt; 结果： 单选按钮1234567891011121314151617&lt;div id="app"&gt; &lt;input type="radio" v-model="picked" value="One" id="one"&gt; &lt;label for="one"&gt;One&lt;/label&gt; &lt;br&gt; &lt;input type="radio" v-model="picked" value="Two" id="two"&gt; &lt;label for="two"&gt;Two&lt;/label&gt; &lt;br&gt; &lt;span&gt;picked: &#123;&#123;picked&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; picked: '' &#125; &#125;)&lt;/script&gt; 结果： 选择框1234567891011121314151617&lt;div id="app"&gt; &lt;select v-model="selected"&gt; &lt;option disabled value=""&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;select: &#123;&#123;selected&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; selected: '' &#125; &#125;)&lt;/script&gt; 注意：如果 v-model 表达式的初始值未能匹配任何选项，&lt;select&gt; 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。 多选时(绑定到一个数组)12345678910111213141516&lt;div id="app"&gt; &lt;select v-model="selected" multiple style="width:50px;"&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;select: &#123;&#123;selected&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; selected: [] &#125; &#125;)&lt;/script&gt; 结果： 用v-for渲染的动态选项12345678910111213141516171819202122&lt;div id="app"&gt; &lt;select v-model="selected"&gt; &lt;option disabled value=""&gt;请选择&lt;/option&gt; &lt;option v-for="option in options" :value="option.value"&gt; &#123;&#123;option.text&#125;&#125; &lt;/option&gt; &lt;/select&gt; &lt;span&gt;selected: &#123;&#123;selected&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; selected: '', options: [ &#123; text: 'One',value: 'A' &#125;, &#123; text: 'Two',value: 'B' &#125;, &#123; text: 'Three',value: 'C' &#125;, ] &#125; &#125;)&lt;/script&gt; 值绑定对于单选按钮，勾选框及选择列表选项， v-model绑定的value通常是静态字符串（对于勾选框是逻辑值）12345678&lt;!-- 当选中时，`picked` 为字符串 "a" --&gt;&lt;input type="radio" v-model="picked" value="a"&gt;&lt;!-- `toggle` 为 true 或 false --&gt;&lt;input type="checkbox" v-model="toggle"&gt;&lt;!-- 当选中时，`selected` 为字符串 "abc" --&gt;&lt;select v-model="selected"&gt; &lt;option value="abc"&gt;ABC&lt;/option&gt;&lt;/select&gt; 但若要绑定value到Vue实例的一个动态属性上，就可以用v-bind实现，并且这个属性的值可以不是字符串1234567891011121314151617&lt;div id="app"&gt; &lt;form action="/xxx" method="post"&gt; &lt;input type="checkbox" v-model="toggle" :true-value="a" :false-value="b" name="yyy"&gt; &lt;span&gt;&#123;&#123;toggle&#125;&#125;&lt;/span&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; toggle: '', a: true, b: false &#125; &#125;)&lt;/script&gt; 注意：这里的 true-value 和 false-value 特性并不会影响输入控件的 value 特性，因为浏览器在提交表单时并不会包含未被选中的复选框。如果要确保表单中这两个值中的一个能够被提交，(比如“true”或“false”)，请换用单选按钮。例如：可以看到value的值并没有提交过来 改用单选按钮1234567891011121314151617&lt;div id="app"&gt; &lt;form action="/xxx" method="post"&gt; &lt;input type="radio" v-model="pick" :value="a" name="yyy"&gt; &lt;span&gt;&#123;&#123;pick&#125;&#125;&lt;/span&gt; &lt;br&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; pick: '', a: true &#125; &#125;)&lt;/script&gt; 结果：这次可以看到value的值被提交过来了 修饰符.lazy在默认情况下， v-model在input事件中同步输入框的值与数据，但可以添加一个修饰符 lazy ，从而转变为在change事件中同步.下列例子中，光标移出输入框时，才同步数据。123456789101112&lt;div id="app"&gt; &lt;input type="text" v-model.lazy="message" placeholder="eidt me"&gt; &lt;p&gt;Message is: &#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; message: '' &#125; &#125;)&lt;/script&gt; 结果： .number如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：1&lt;input v-model.number="age" type="number"&gt; 这通常很有用，因为即使在 type=”number” 时，HTML 输入元素的值也总会返回字符串。12345678910111213141516171819202122232425&lt;div id="app"&gt; &lt;input type="number" v-model="age1"&gt; &lt;span&gt;&#123;&#123;type1&#125;&#125;&lt;/span&gt; &lt;p&gt;普通输入：&#123;&#123;age1&#125;&#125;&lt;/p&gt; &lt;input type="number" v-model.number="age2"&gt; &lt;span&gt;&#123;&#123;type2&#125;&#125;&lt;/span&gt; &lt;p&gt;.number修饰符输入：&#123;&#123;age2&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; age1: '', age2: '' &#125;, computed: &#123; type1() &#123; return typeof this.age1 &#125;, type2() &#123; return typeof this.age2 &#125; &#125; &#125;)&lt;/script&gt; 结果： .trim如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：1&lt;input v-model.trim="msg"&gt;]]></content>
      <categories>
        <category>跟着文档学vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件处理]]></title>
    <url>%2F2018%2F01%2F%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86.html</url>
    <content type="text"><![CDATA[不同于传统的通过js操作DOM来更新数据，vue为我们提供了一系列的指令监听DOM事件。 监听事件通过v-on指令来绑定事件监听器123456789101112 &lt;div id="app"&gt; &lt;button @click="counter += 1"&gt;增加1&lt;/button&gt; &lt;p&gt;这个按钮被点击了&#123;&#123;counter&#125;&#125;次&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; counter: 0 &#125; &#125;)&lt;/script&gt; 方法许多事件处理的逻辑都很复杂，所以直接把JS代码写在 v-on 指令中有时并不可行。v-on指令可以接收一个定义的方法来调用。注意：不应该使用箭头函数来定义methods函数，因为箭头函数绑定了父级作用域的上下文，所以this将不会按照期望指向 Vue 实例。12345678910111213141516171819&lt;div id="app"&gt; &lt;button @click="increment"&gt;增加1&lt;/button&gt; &lt;p&gt;这个按钮被点击了&#123;&#123;counter&#125;&#125;次&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; counter: 0, message: '' &#125;, methods: &#123; increment(e) &#123; console.log(e) this.message = `被点击了$&#123;this.counter += 1&#125;次` &#125; &#125; &#125;)&lt;/script&gt; 内联处理器中的方法除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法。1234567891011121314 &lt;div id="app"&gt; &lt;button @click="say('hi')"&gt;say hi&lt;/button&gt; &lt;button @click="say('what')"&gt;say what&lt;/button&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', methods: &#123; say(message) &#123; alert(message) &#125; &#125; &#125;)&lt;/script&gt; 有时也需要在内联语句处理器中访问原生 DOM 事件。可以用特殊变量 $event 把它传入方法123456789101112131415&lt;div id="app"&gt; &lt;button @click="say('hi',$event)"&gt;say hi&lt;/button&gt; &lt;button @click="say('what',$event)"&gt;say what&lt;/button&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', methods: &#123; say(message,e) &#123; console.log(message) console.log(e.target) &#125; &#125; &#125;)&lt;/script&gt; 结果： 事件修饰符在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 .stop 阻止maopao .prevent 阻止默认事件 .capture 使用事件捕获模式 .self 只在当前元素本身触发 .once 只触发一次 注意：使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 @click.prevent.self 会阻止所有的点击，而 @click.self.prevent 只会阻止对元素自身的点击。 阻止冒泡1234567891011121314151617181920212223&lt;div id="app"&gt; &lt;div class="box1" @click="fn1"&gt;box1 &lt;div class="box2" @click.stop="fn2"&gt;box2 &lt;div class="box3" @click="fn3"&gt;box3&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', methods: &#123; fn1() &#123; console.log('box1被点击了') &#125;, fn2() &#123; console.log('box2被点击了') &#125;, fn3() &#123; console.log('box3被点击了') &#125; &#125; &#125;)&lt;/script&gt; 当点击box3时，可以看到box2的点击事件被触发了，box1的点击事件没有被触发 事件捕获12345&lt;div class="box1" @click="fn1"&gt;box1 &lt;div class="box2" @click.capture="fn2"&gt;box2 &lt;div class="box3" @click="fn3"&gt;box3&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 结果：可以看到box2的事件处理函数是在捕获阶段处理的，而box1,box3的事件处理函数仍然是在冒泡阶段处理 鼠标修饰符1234567891011121314151617181920212223&lt;div id="app"&gt; &lt;button @mouseup.left="left" @mouseup.middle="middle" @mouseup.right="right"&gt;click me&lt;/button&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; message: '' &#125;, methods: &#123; left() &#123; this.message = '鼠标左键点击了' &#125;, middle() &#123; this.message = '鼠标滑轮键点击了' &#125;, right() &#123; this.message = '鼠标右键点击了' &#125; &#125; &#125;)&lt;/script&gt; 结果： 键值修饰符在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符：12345678910111213141516171819202122232425262728&lt;div id="app"&gt; &lt;button @keyup.enter="enter" @keyup.delete="delete1" @keyup.esc="esc1" @keyup.space="space" @keyup.up="up"&gt;&#123;&#123;message&#125;&#125;&lt;/button&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; message: '将光标置于按钮上后，按下键盘上不同的按键，会有不同的效果' &#125;, methods: &#123; enter()&#123; this.message = 'enter' &#125;, delete1()&#123; this.message = 'delete' &#125;, esc1()&#123; this.message = 'esc' &#125;, space()&#123; this.message = 'space' &#125;, up()&#123; this.message = 'up' &#125; &#125; &#125;)&lt;/script&gt; 结果： 系统修饰键可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。vue2.5.0新增了.exact修饰符，允许你控制由精确的系统修饰符组合触发的事件。 .ctrl .shift .alt .meta (在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。)12345678910111213141516171819202122&lt;div id="app"&gt; &lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt; &lt;button @click.ctrl="onClick"&gt;A&lt;/button&gt; &lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt; &lt;button @click.ctrl.exact="onClick"&gt;B&lt;/button&gt; &lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt; &lt;button @click.exact="onClick"&gt;C&lt;/button&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; message: '' &#125;, methods: &#123; onClick(e) &#123; this.message = `$&#123;e.target.innerText&#125;被点击了` &#125; &#125; &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>跟着文档学vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表渲染]]></title>
    <url>%2F2018%2F01%2F%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93.html</url>
    <content type="text"><![CDATA[数组的v-for我们可以用 v-for 指令根据一组数组的选项列表进行渲染。在 v-for 块中，我们拥有对父作用域属性的完全访问权限。12345678910111213141516171819&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="(item,index) in items"&gt; &#123;&#123;parentMessage&#125;&#125; - &#123;&#123;index&#125;&#125; - &#123;&#123;item.message&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; let app = new Vue(&#123; el: '#app', data: &#123; parentMessage: 'Parent', items: [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125;, ] &#125;, &#125;)&lt;/script&gt; 渲染出来的结果为也可以用of代替in作为分隔符1&lt;li v-for="(item,index) of items"&gt; 对象的v-for12345678910111213141516171819&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="(value,key,index) of object"&gt; &#123;&#123;index&#125;&#125;.&#123;&#123;key&#125;&#125; - &#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; let app = new Vue(&#123; el: '#app', data: &#123; object: &#123; firstName: 'John', lastname: 'Doe', age: 30 &#125; &#125;, &#125;)&lt;/script&gt; 结果：注意：在遍历对象时，是按 Object.keys() 的结果遍历 一段取值的v-forv-for 也可以取整数。在这种情况下，它将重复多次模板。123&lt;div&gt; &lt;span v-for="n in 10"&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt;&lt;/div&gt; v-fon on a template类似于 v-if，也可以利用带有 v-for 的 template 渲染多个元素。比如：123456&lt;ul&gt; &lt;template v-for="item in items"&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class="divider"&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; v-for with v-if当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。1234567891011121314151617&lt;ul id="app"&gt; &lt;li v-for="item in items" v-if="item.isShow"&gt; &#123;&#123;item.message&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; items: [ &#123; isShow: true, message: 'Foo' &#125;, &#123; isShow: false, message: 'Bar' &#125;, &#123; isShow: true, message: 'Baz' &#125;, ] &#125; &#125;)&lt;/script&gt; 结果：如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素 (或 template)上。如：123456&lt;ul v-if="todos.length"&gt; &lt;li v-for="todo in todos"&gt; &#123;&#123; todo &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No todos left!&lt;/p&gt; 数组更新检测变异方法(这些方法直接改变原数组)，这些方法将会触发视图更新。例如：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div id="app"&gt; &lt;button @click="push"&gt;push&lt;/button&gt; &lt;button @click="pop"&gt;pop&lt;/button&gt; &lt;button @click="shift"&gt;shift&lt;/button&gt; &lt;button @click="unshift"&gt;unshift&lt;/button&gt; &lt;button @click="splice"&gt;splice&lt;/button&gt; &lt;button @click="sort"&gt;sort&lt;/button&gt; &lt;button @click="reverse"&gt;reverse&lt;/button&gt; &lt;ul&gt; &lt;li v-for="item in items"&gt; &#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; let app = new Vue(&#123; el: '#app', data: &#123; items: [ 666, 222, 333 ], addValue: 444 &#125;, methods: &#123; push() &#123; this.items.push(this.addValue) &#125;, pop() &#123; this.items.pop() &#125;, shift() &#123; this.items.shift() &#125;, unshift() &#123; this.items.unshift(this.addValue) &#125;, splice() &#123; this.items.splice(0,1) &#125;, sort() &#123; this.items.sort() &#125;, reverse() &#123; this.items.reverse() &#125; &#125; &#125;)&lt;/script&gt; 非变异方法(不会改变原数组)例：12345methods: &#123; slice() &#123; this.items = this.items.slice(0,1) &#125;&#125; 无法检测由于 JavaScript 的限制，Vue 不能检测以下变动的数组：1.当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue2.当你修改数组的长度时，例如：vm.items.length = newLength123456789101112131415161718192021222324252627282930313233&lt;div id="app"&gt; &lt;button @click="setValue"&gt;setValue&lt;/button&gt; &lt;button @click="setLength"&gt;setLength&lt;/button&gt; &lt;ul&gt; &lt;li v-for="item in items"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; items: ['Foo','Bar','Baz'], message: '' &#125;, watch: &#123; items() &#123; this.message = '数据发生变化', setTimeout(() =&gt; &#123; this.message = '' &#125;,1000) &#125; &#125;, methods: &#123; setValue() &#123; this.items[0] = 'match' &#125;, setLength() &#123; this.items.length = 0 &#125; &#125; &#125;) &lt;/script&gt; 上面的例子，无法触发视图更新 对于上诉两类问题，分别可以通过以下方式解决Vue.set(example.items, indexOfItem, newValue)example.items.splice(newLength)12345678methods: &#123; setValue() &#123; Vue.set(this.items,0,'match') &#125;, setLength() &#123; this.items.splice(0) &#125; &#125; 对象更改检测注意事项还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：123456789var vm = new Vue(&#123; data: &#123; a: 1 &#125;&#125;)// vm.a 现在是响应式的vm.b = 2// vm.b 不是响应式的 对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性。还可以为已有对象添加多个属性，比如使用Object.assign()。例如:12345678910111213141516171819202122232425262728293031 &lt;ul id="app"&gt; &lt;li v-for="(value,key,index) in object"&gt; &#123;&#123;index&#125;&#125;.&#123;&#123;key&#125;&#125; : &#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;button @click="fn"&gt;click me&lt;/button&gt;&lt;/ul&gt;&lt;script&gt; let vm = new Vue(&#123; el:'#app', data: &#123; object: &#123; firstName: 'john', lastName: 'Doe', age: 30 &#125; &#125;, methods: &#123; fn() &#123; Vue.set(this.object,'hoby','music') // vue实例的方法 // vm.$set(this.object,'hoby','music') // 添加多个属性 this.object = Object.assign(&#123;&#125;,this.object,&#123; gender: 'male', professional: 'doctor' &#125;) &#125; &#125; &#125;)&lt;/script&gt; 显示过滤/排序结果有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以使用计算属性或者methods方法1234567891011121314151617181920212223242526&lt;ul id="app"&gt; &lt;li v-for="n in evenNumbers"&gt;&#123;&#123;n&#125;&#125;&lt;/li&gt; &lt;!-- &lt;li v-for="n in even(numbers)"&gt;&#123;&#123;n&#125;&#125;&lt;/li&gt; --&gt;&lt;/ul&gt;&lt;script&gt; let vm = new Vue(&#123; el:'#app', data: &#123; numbers: [1,2,3,4,5] &#125;, computed: &#123; evenNumbers: function() &#123; return this.numbers.filter((number)=&gt;&#123; return number % 2 === 0 &#125;) &#125; &#125;, // methods: &#123; // even: function(numbers) &#123; // return this.numbers.filter((number) =&gt; &#123; // return number % 2 === 0 // &#125;) // &#125; // &#125; &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>跟着文档学vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条件渲染]]></title>
    <url>%2F2018%2F01%2F%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93.html</url>
    <content type="text"><![CDATA[v-if根据表达式的值得真假条件渲染元素。赋值为true时，将元素插入DOM，否则从DOM中移除。123456789101112&lt;div id="app" v-if="seen"&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script&gt; let app = new Vue(&#123; el: '#app', data: &#123; message: 'hello vue', seen: true &#125; &#125;)&lt;/script&gt; 如果想切换多个元素，可以把一个template元素当做包装元素，并在上面使用v-if。最终的渲染结果不会包含template元素1234567&lt;div id="app"&gt; &lt;template v-if="seen"&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;p&gt;段落1&lt;/p&gt; &lt;p&gt;段落2&lt;/p&gt; &lt;/template&gt;&lt;/div&gt; v-if还可以配合v-else-if,v-else来使用1234567891011121314&lt;div id="app"&gt; &lt;p v-if="type === 'A'"&gt;A&lt;/p&gt; &lt;p v-else-if="type === 'B'"&gt;B&lt;/p&gt; &lt;p v-else-if="type === 'C'"&gt;C&lt;/p&gt; &lt;p v-else="type === 'D'"&gt;D&lt;/p&gt;&lt;/div&gt;&lt;script&gt; let app = new Vue(&#123; el: '#app', data: &#123; type: 'A' &#125; &#125;)&lt;/script&gt; 用key管理可复用的元素Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：12345678910111213141516171819202122232425&lt;div id="app"&gt; &lt;template v-if="loginType === 'username'"&gt; &lt;label&gt;用户名&lt;/label&gt; &lt;input type="text" placeholder="输入用户名"&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;label&gt;邮箱&lt;/label&gt; &lt;input type="text" placeholder="输入邮箱地址"&gt; &lt;/template&gt; &lt;br&gt; &lt;button @click="toggle"&gt;切换状态&lt;/button&gt;&lt;/div&gt;&lt;script&gt; let app = new Vue(&#123; el: '#app', data: &#123; loginType: 'username' &#125;, methods: &#123; toggle() &#123; this.loginType = this.loginType === 'username' ? '' : 'username' &#125; &#125; &#125;)&lt;/script&gt; 这样也不总是符合实际需求，所以Vue提供了一种方式来声明“这两个元素是完全独立的——不要复用它们”。只需添加一个具有唯一值的key属性即可12&lt;input type="text" placeholder="输入用户名" key="username-input"&gt;&lt;input type="text" placeholder="输入邮箱地址" key="email-input"&gt; 另一个用于根据条件展示元素的选项是 v-show 指令，用法大致一样。注意，v-show 不支持 &lt;template&gt; 元素，也不支持 v-else。它们的不同之处在于：v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。]]></content>
      <categories>
        <category>跟着文档学vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算属性]]></title>
    <url>%2F2018%2F01%2F%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7.html</url>
    <content type="text"><![CDATA[computed之前说到我们可以在模板内使用javaScript单一表达式123&lt;div id="example"&gt; &#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/div&gt; 但是假设我们需要在很多地方都用到这一个转化的话，无疑让代码看起来很臃肿。我们可以用计算属性解决这个问题12345678910111213141516171819&lt;div id="app"&gt; &lt;p&gt;Original message: &#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;p&gt;Computed reversed message: &#123;&#123;reversedMessage&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; let vm = new Vue(&#123; el: '#app', data: &#123; message: 'Hello' &#125;, computed: &#123; // 计算属性的getter reversedMessage() &#123; // this指向vm实例 return this.message.split('').reverse().join('') &#125; &#125; &#125;)&lt;/script&gt; 我们先在浏览器看看结果数据是能显示了，但是我们接下来要试试是不是响应式的。首先，我们先加入一个钩子函数用来测试数据是不是更新了123updated() &#123; console.log('this.message is updated')&#125; 然后在浏览器做实验，我们可以看到数据确实更新了接下里我们在浏览器试着改一下计算属性的值我们发现报错了，这是为什么呢？官方文档中说了，我们定义在computed中的函数作为计算属性的getter函数。也就是说，我们只能读取这个计算属性。当然我们也可以自己写一个setter函数来让计算属性有写的能力12345678910111213141516171819let vm = new Vue(&#123; el: '#app', data: &#123; message: 'Hello' &#125;, computed: &#123; reversedMessage: &#123; get() &#123; return this.message.split('').reverse().join('') &#125;, set(newValue) &#123; this.message = newValue.split('').reverse().join('') &#125; &#125; &#125;, updated() &#123; console.log('this.message is updated') &#125; &#125;) methods对于上面中的例子，用methods也可以是先同样的效果1234567891011121314151617181920&lt;div id="app"&gt; &lt;p&gt;Original message: &#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;p&gt;Computed reversed message: &#123;&#123;reversedMessage()&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; let vm = new Vue(&#123; el: '#app', data: &#123; message: 'Hello' &#125;, methods: &#123; reversedMessage() &#123; return this.message.split('').reverse().join('') &#125; &#125;, updated() &#123; console.log('this.message is updated') &#125; &#125;)&lt;/script&gt; 都能达到同样的效果，它们之间的区别在哪呢？官方文档中说了，不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数 watch利用vue提供的侦听属性也可以达到上面同样的效果。123456789101112131415161718192021&lt;div id="app"&gt; &lt;p&gt;Original message: &#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;p&gt;Computed reversed message: &#123;&#123;reversedMessage&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; let vm = new Vue(&#123; el: '#app', data: &#123; message: 'Hello', reversedMessage:'' &#125;, watch: &#123; message() &#123; this.reversedMessage = this.message.split('').reverse().join('') &#125; &#125;, updated() &#123; console.log('this.message is updated') &#125; &#125;)&lt;/script&gt; 需要注意的是，watch中的对象需要在data中已经定义了。在发生updated的时候才会触发watch。上面的reversedMessage一开始被渲染出的是个空值。watch和computed一样，也会对计算结果进行缓存。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。]]></content>
      <categories>
        <category>跟着文档学vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板语法]]></title>
    <url>%2F2018%2F01%2F%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[插值mustache语法使用双花括号写法，在其中书写表达式，将输出对应的结果。1234567891011&lt;div id="app"&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script&gt; let vm = new Vue(&#123; el: '#app', data: &#123; message: 'hello vue' &#125; &#125;)&lt;/script&gt; 可以在花括号中书写表达式，意味着以下的例子都是合法的123&#123;&#123; num + 1 &#125;&#125;&#123;&#123; bool? 'true' : 'false' &#125;&#125;&#123;&#123; someStr.split('').reverse().join('') &#125;&#125; 但是它仅仅支持单句的表达式，像这样就不合法：12&#123;&#123; if(a)&#123; return a &#125; &#125;&#125; //不支持流程控制&#123;&#123; var a = 1 &#125;&#125; //这是语句，不是表达式 v-html现在假设message中的内容是1message: '&lt;p&gt;hello&lt;/p&gt;' 输出结果如下，并没有输出我们想要的结果。怎样输出成html呢？这是需要一个指令v-html来帮我们到达效果了12345678910&lt;div id="app" v-html="message"&gt;&lt;/div&gt; &lt;script src="./vue.js"&gt;&lt;/script&gt; &lt;script&gt; let vm = new Vue(&#123; el: '#app', data: &#123; message: '&lt;p&gt;hello&lt;/p&gt;' &#125; &#125;) &lt;/script&gt; v-once但是又有些时候，我们只希望页面初始化的时候绑定这些数据，不希望如果以后数据发生改变的话，这些DOM中的内容也跟着改变，这时候就需要用到v-once指令了12&lt;p v-once v-html="message"&gt;&lt;/p&gt;&lt;p v-once&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; v-bindmustache语法不能作用在html属性上，遇上这种情况，应该使用v-bind指令，vue为我们提供了缩写形式1234567891011&lt;div id="app"&gt; &lt;p :id="`hi-$&#123;id&#125;`"&gt;hello&lt;/p&gt;&lt;/div&gt;&lt;script&gt; let vm = new Vue(&#123; el: '#app', data: &#123; id: 1 &#125; &#125;)&lt;/script&gt; 需要注意的是bind的属性值是falthy值得话，vue不会将这个属性渲染出来]]></content>
      <categories>
        <category>跟着文档学vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的生命周期]]></title>
    <url>%2F2018%2F01%2Fvue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html</url>
    <content type="text"><![CDATA[实例生命周期Vue的官方文档是这么解释的 每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如需要设置数据监听、编译模板、挂载实例到 DOM、在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码。 作为一个萌新看到这里已经懵逼了，还是自己动手做实验来理解吧12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;input v-model="message"&gt; &lt;/div&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: '#app', data: &#123; message: 'Hellow Vue' &#125;, beforeCreate: function() &#123; console.log('--------beforeCreate--------') console.log(this.message) console.log(this.$el) &#125;, created: function() &#123; console.log('--------created--------') console.log(this.message) console.log(this.$el) &#125;, beforeMount: function() &#123; console.log('--------beforeMount--------') console.log(this.message) console.log(this.$el) &#125;, mounted: function() &#123; console.log('--------mounted--------') console.log(this.message) console.log(this.$el) &#125;, beforeUpdate: function() &#123; console.log('--------beforeUpdate--------') console.log(this.message) console.log(this.$el) &#125;, updated: function() &#123; console.log('--------updated--------') console.log(this.message) console.log(this.$el) &#125;, beforeDestroy: function() &#123; console.log('--------beforeDestroy--------') console.log(this.message) console.log(this.$el) &#125;, destroyed: function() &#123; console.log('--------destroyed--------') console.log(this.message) console.log(this.$el) &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打开页面后，会再控制台看到这样的输出 所以我们可以得出一些结论 beforeCreated: 在vue的实例构造的第一步就触发这个钩子，什么数据都还没绑定 created: 数据已经被绑定触发的钩子 beforeMount: vue已经绑定到元素身上，但是还没有把数据同步给相应的元素 mounted: vue已经绑定到元素身上，并且数据已经同步到相应的元素 这个时候我们在输入框中输入一些内容，结果如下 这个时候发现两个钩子函数，输出的内容是一样的。那么区别在哪呢？ 有些时候可能在更新某个元素状态时需要做一些判断，那么这些操作必须写在beforeUpdate里面，因为这个时候虚拟DOM还没有重新渲染。而updated是已经渲染完毕后才执行的，如果在updated中更改一个元素的状态，极有可能导致无限循坏，这点要注意。 默认情况下，vue实例不会自己死掉，需要人为来操作。这里用一个实例方法:$destroy beforeDestroy: 在死之前还能控制那些被绑定的元素、数据、事件 destroyed: 已经死了，没办法控制之前绑定的元素了，所有的事件监听器都被移除了，如果有子实例的话，子实例的所有绑定也会被移除，再也没有响应式了]]></content>
      <categories>
        <category>跟着文档学vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue实例]]></title>
    <url>%2F2018%2F01%2FVue%E5%AE%9E%E4%BE%8B.html</url>
    <content type="text"><![CDATA[data当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。1234567891011121314&lt;div id="app"&gt;&lt;/div&gt; &lt;script src="./vue.js"&gt;&lt;/script&gt; &lt;script&gt; let value = &#123; message: 'hello vue' &#125; let vm = new Vue(&#123; el: '#app', data: value &#125;) console.log(vm.message === value.message) //true vm.message = 2 console.log(value.message) //2 value.message = 3 console.log(vm.message) //3 &lt;/script&gt; 被代理的属性是响应的，也就是说值的任何改变都是触发视图的重新渲染。设置属性也会影响到原始数据，反之亦然。但是只有当实例被创建时 data 中存在的属性才是响应式的。例如：1vm.a = 'hi' 那么对a的改动将不会触发任何更新 这里唯一的例外是使用 Object.freeze()，这会阻止修改现有的属性，也意味着响应系统无法再追踪变化。12345&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;obj.foo&#125;&#125;&lt;/p&gt; // 这里点击时将不会触发更新 &lt;button @click="obj.foo ='baz'"&gt;change it&lt;/button&gt;&lt;/div&gt; 123456789101112131415 &lt;script&gt; let obj = &#123; foo: 'bar' &#125; Object.freeze(obj) new Vue(&#123; el: '#app', data() &#123; return &#123; obj &#125; &#125; &#125;) &lt;/script&gt;``` Vue 实例还暴露了一些有用的实例属性与方法。它们都有前缀 $，以便与用户定义的属性区分开来。123456let value = &#123; message: 'hello vue' &#125;let vm = new Vue(&#123; el: '#app', data: value&#125;)console.log(vm.$data === value)]]></content>
      <categories>
        <category>跟着文档学vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的扩展]]></title>
    <url>%2F2018%2F01%2F%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95.html</url>
    <content type="text"><![CDATA[扩展运算符相当于rest参数的逆运算，将一个数组转换为用逗号分隔的参数序列。使用扩展运算符可以代替apply方法1234567console.log(1,...[2,3,4],5) //1 2 3 4 5//求数组最大值，es5Math.max.apply(null,[1,4,77]) //77// es6Math.max(...[1,4,77]) //77 扩展运算符的应用复制数组数组是也是对象，直接复制的话，只是复制了指向底层数据的指针。所以要采取一些方法来克隆一个全新的数组12345678910//es5const a1 = [1,2]const a2 = a1.concat()//es6const a1 = [1,2]//第一种写法const a2 = [...a1]//第二种写法,利用解构赋值const [...a2] = a1 数组合并123456789const arr1 = ['a', 'b']const arr2 = ['c']const arr3 = ['d', 'e']//es5const newArr = arr1.concat(arr2,arr3)//es6[...arr1,...arr2,...arr3] 与解构赋值结合1234567const [first,...rest] = [1,2,3,4,5]first //[1]rest //[2,3,4,5]const [first,...rest] = []first //undefinedrest //[] 字符串扩展运算符可以将字符串转换为真正的数组12[...'hello] // [ 'h', 'e', 'l', 'l', 'o' ] 实现了Iterator接口的对象任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组。123456789101112let nodeList = document.querySelectorAll('div')let arr = [...nodeList]--------let arrayLike = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3&#125;let arr = [...arrayLike] //arrayLike is not iterable Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map） 扩展运算符也可以将某些数据机构转换为数组，两者有什么区别呢？ 简单来说，Array.from()只要是类数组对象和具有iterator的对象都可以转换为数组，而扩展运算符只能将具有iterator接口的对象转换为数组。12345678let arrayLike = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3&#125;let arr = Array.from(arrayLike) arr //['a','b','c'] Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。12345678910let arrayLike = &#123; 0: '1', 1: '2', 2: '3', length: 3&#125;let arr = Array.from(arrayLike).map(x =&gt; x * x)//等价于let arr = Array.from(arrayLike,x =&gt; x * x)arr //[1,4,9] Array.of()Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组1234Array.of() //[]Array.of(undefined) //[undefined]Array.of(1) //[1]Array.of(1,2) //[1,2] find()和findIndex()第一个参数是回调函数。都是用于找出第一个符合条件的数组成员。find()方法是返回该成员，如果找不到则返回undefined;findIndex()方法是返回该成员的索引，如果找不多符合条件的则返回-1。可以接受第二个参数，来绑定this对象12345678910let s = [1,4,-5,10].find((value,index,arr) =&gt; &#123; return value &lt; 10&#125;)console.log(s) //1let person = &#123; name: 'John',age: 20 &#125;let s = [10,12,26,15].findIndex(function(item) &#123; return item &gt; this.age&#125;,person)console.log(s) //2,思考这里的回调函数为什么不能用箭头函数 fill()fill方法使用给定值，填充一个数组。123['a','b','c'].fill(7) //[7,7,7]['a','b','c'].fill(7,1) //['a',7,7]['a','b','c'].fill(7,1,2) //['a',7,'c'] includes()该方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似比起传统的indexOf方法，includes不会对NaN误判12[NaN].indexOf(NaN) //-1[NaN].includes(NaN) //true 数组的空位数组的空位指，数组的某一个位置没有任何值。空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值。空位的处理规则非常不统一，所以建议避免出现空位。12345678910111213141516171819202122232425262728293031323334353637383940let arr = ['a',,'b']// for infor(let i in arr) &#123; console.log(arr[i]) // a,b&#125;// forEacharr.forEach(value =&gt; console.log(value)) // a,b// filterarr.filter(x =&gt; return true) //[a,b]// every[,'a'].every(x =&gt; x === 'a') //true// some[,'a'].some(x =&gt; x !== 'a') //false// maparr.map(x =&gt; 1) //[1,,1]// reduce[1,,2].reduce((x,y) =&gt; x + y) //3// join[,'a',undefined,null].join('#') //#a##// toString[,'a',undefined,null].toString('') //,a,,// fromArray.from(arr) //['a',undefined,'b']// 扩展运算符[...arr] //['a',undefined,'b']// for offor(let i of arr) &#123; console.log(i) // a,undefined,b&#125; forEach(), filter(), reduce(), every() 和some()都会跳过空位。map()会跳过空位，但会保留这个值join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。for in和for of一般用来遍历对象，不推荐用来遍历数组。for in用来遍历键名，会跳过空位。for of用来遍历键值，不会跳过空位entries()、keys()、values()、find()和findIndex()会将空位处理成undefined]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数扩展]]></title>
    <url>%2F2018%2F01%2F%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95.html</url>
    <content type="text"><![CDATA[函数参数的默认值在es6之前为函数参数指定默认值需要这么写1234567function log(x,y) &#123; y = y || 'world' console.log(x,y)&#125;log('hello') //hello worldlog('hello','es6') //hello es6log('hello','') //hello world 由此也带来一个问题，如果参数y被赋值了，但是对应的布尔值为false(空字符串的布尔值为false)，则该赋值不起作用，如上面代码最后一行 在es6中允许为函数参数直接指定默认值123456function log(x,y = 'world') &#123; console.log(x,y)&#125;log('hello') //hello worldlog('hello','es6') //hello es6log('hello','') //hello 参数默认值的位置通常情况，定义默认值的参数应该是尾参数。如果非尾部的参数设置默认值，实际上这个参数是不能省略的1234567function f(x = 1,y) &#123; return [x,y]&#125;f() //[1,undefined]f(2) //[2,undefined]f(undefined,1) //[1,1]f(,1) //报错 函数的length属性指定了默认值后，函数的length属性将返回没有指定默认值的参数个数。123(function(a)&#123;&#125;).length //1(function(a = 5)&#123;&#125;).length //0(function(a,b,c = 5)&#123;&#125;).length //2 因为length属性的含义是，该函数预期传入的参数个数。设置了某个参数的默认值后，预期传入的参数就不包含这个参数了。同理resr参数也不会计入length属性1(function(...args)&#123;&#125;).length //0 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了12function(a = 0,b,c)&#123;&#125;.length //0function(a,b = 1,c)&#123;&#125;.length //1 作用域一旦设置了参数的默认值，函数进行声明初始化的时候，参数会形成一个单独的作用域。等到初始化结束，这个作用域会消失12345let x = 1function f(x,y = x) &#123; console.log(y)&#125;f(2) //2 上面代码中，参数y的值默认值等于变量x。调用函数f时，参数形成一个单独的作用域。这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x 再看看下面的例子123456let x = 1function f(y = x) &#123; let x = 2 console.log(y)&#125;f() //1 上面代码中，函数f调用时，参数y=x形成一个单独的作用域。这个作用域里面变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内的局部变量影响不到默认值变量x。如果全局变量不存在就会报错 如果参数的默认值是一个函数，该函数的作用域也遵循这个规则123456let foo = 'outer'function bar(func = () =&gt; foo) &#123; let foo = 'inner' console.log(func())&#125;bar() //outer 下面是一个更复杂的例子12345678var x = 1function foo(x,y = function() &#123;x = 2&#125;) &#123; var x = 3 y() console.log(x)&#125;foo() //3x //1 上面代码中，函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。 如果将var x = 3的var去除，函数foo的内部变量x就指向第一个参数x，与匿名函数内部的x是一致的，所以最后输出的就是2，而外层的全局变量x依然不受影响。12345678var x = 1function foo(x,y = function() &#123;x = 2&#125;) &#123; x = 3 y() console.log(x)&#125;foo() //2x //1 rest参数es6引入了rest参数，用于获取函数的多余参数，这样就不需要使用arguments对象了12345678910//在es5中对参数求和需要这么写function add() &#123; let sum = 0 return [].reduce.call(arguments,(cur,next) =&gt; cur + next)&#125;add(2,5,3) //10//利用es6的rest参数可以这么写const add = (...args) =&gt; args.reduce((cur,next) =&gt; cur + next)add(2,5,3) //10 注意：rest参数只能是最后一个参数 箭头函数1.函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。2.不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。3.不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。4.不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 一个箭头函数绑定this的作用域的例子123456789101112function Timer() &#123; this.s1 = 0 this.s2 = 0 setInterval(() =&gt; this.s1++,1000) setInterval(function() &#123; this.s2++ &#125;,1000)&#125;var timer = new Timer()setTimeout(() =&gt; console.log('s1:',timer.s1), 3100) //3setTimeout(() =&gt; console.log('s2:',timer.s2), 3100) //0 上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1被更新了 3 次，而timer.s2一次都没更新。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解构赋值]]></title>
    <url>%2F2017%2F12%2F%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.html</url>
    <content type="text"><![CDATA[数组的解构赋值例：1234567891011121314151617181920let [foo,[[bar],baz]] = [1,[[2],3]]foo //1bar //2baz //3let [,,third] = ['foo','bar','baz']third //bazlet [x,,y] = [1,2,3]x //1y //3let [head,...tail] = [1,2,3,4]head //1tail //[2,3,4]let [a,b,...c] = ['a']a //ab //undefinedc //[] 这种写法属于”模式匹配“，只要等式两边的模式相同，左边的变量就会被赋予对应的值如果解构不成功，变量的值就等于undefined 还有一种不完全解构，等号左边的模式只匹配右边的一部分123let [x,y] = [1,2,3]x //1y //2 如果等号右边不是数组，或者是不可遍历的结构，会报错1234567// 报错let [foo] = 1let [foo] = falselet [foo] = NaNlet [foo] = undefinedlet [foo] = nulllet [foo] = &#123;&#125; 默认值解构赋值允许指定默认值。ES6内部使用严格相等运算符（===），判断一个位置是否有值。如果一个数组成员不严格等于undefined，默认值不会生效。12345let [x = 1] = [undefined]x //1let [x = 1] = [null]x //null 如果默认值是一个表达式，那么这个表达式是惰性求值的。123456789101112function f() &#123; console.log('aaa')&#125;let [x = f()] = [1]x //1function f() &#123; console.log('aaa') return 'aaa'&#125;let [x = f()] = [undefined]x //'aaa' 对象的解构赋值对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值有位置决定。对象的属性没有次序，变量必须属性名相同的才能取到正确的值123456let &#123; bar, foo &#125; = &#123;foo: 'aaa',bar: 'bbb'&#125;bar //'bbb'foo //'aaa'// 上面其实是下面的简写let &#123; bar: bar,foo: foo &#125; = &#123; foo: 'aaa',bar: 'bbb' &#125; 说明对象的解构是先找到同名属性，再将值赋予对应的变量 字符串的解构赋值字符串在解构赋值时，被转换成了一个类似数组的对象。类数组对象都有length属性， 可以对这个属性解构赋值12let &#123; length:len &#125; = 'abcdef'len //6 数值和布尔值的解构赋值解构赋值时，会先将等号右边数值或布尔值转换为对象1234let &#123; toString: s &#125; = 123s === Number.prototype.toString //truelet &#123; toString: s &#125; = trues === Boolean.prototype.toString //true 函数参数的解构赋值注意下面两种方法的区别12345678910111213141516171819function move(&#123; x = 0,y = 0 &#125; = &#123;&#125;) &#123; return [x,y];&#125;move(&#123; x: 3,y: 8 &#125;) //[3,8]move(&#123; x: 3 &#125;) //[3,0]move(&#123;&#125;) //[0,0]move() //[0,0]// 上面代码中，函数的参数是一个对象，通过对这个对象解构，得到变量x,y的值，如果解构失败，x,y等于默认值-------// 下面代码是为函数的参数指定默认值，而不是为变量x,y指定默认值function move(&#123;x, y&#125; = &#123;x: 0, y: 0&#125;) &#123; return [x,y];&#125;move(&#123; x: 3,y: 8 &#125;) //[3,8]move(&#123; x: 3 &#125;) //[3,undefined]move(&#123;&#125;) //[undefined,undefined]move() //[0,0]]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scss学习]]></title>
    <url>%2F2017%2F12%2Fscss%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[scss中的继承(@extend)在SASS的继承是把一个选择器的所有样式继承到另一个选择器上，在继承另一个选择器的样式时需要使用@extend开始，后面紧跟被继承的选择器 比较下这两段代码的区别123456789101112131415161718192021222324252627/*style.scss*/.block &#123; margin: 10px 5px; padding: 2px;&#125;p &#123; @extend .block; border: 1px solid #eee;&#125;ul,ol &#123; @extend .block; color: #333; text-transform: uppercase;&#125;/*编译后的结果*//*style.css*/.block, p, ul, ol &#123; margin: 10px 5px; padding: 2px; &#125;p &#123; border: 1px solid #eee; &#125;ul, ol &#123; color: #333; text-transform: uppercase; &#125; 1234567891011121314151617181920212223242526/*style.scss*/%block &#123; margin: 10px 5px; padding: 2px;&#125;p &#123; @extend %block; border: 1px solid #eee;&#125;ul,ol &#123; @extend %block; color: #333; text-transform: uppercase;&#125;/*编译后的结果*//*style.css*/p, ul, ol &#123; margin: 10px 5px; padding: 2px; &#125;p &#123; border: 1px solid #eee; &#125;ul, ol &#123; color: #333; text-transform: uppercase; &#125; 混合(@mixin)Mixins是SASS最出名特色之一。他充许我们通过@mixin:的方式将相同的样式风格定义成一个模块，然后在需要使用的地方通过@include将@mixin定义好的模块调用进来1234567@mixin Mixins名称(参数:参数值) &#123; /*公用样式*/&#125;div &#123; @include Mixins名称(参数值)&#125; 嵌套的缺点只要你的SASS嵌套的越深，那么编译出来的CSS的选择器就会层级越深。这样一来并不是好事，也不是我们想要的干净代码，换句话来说，直接违背了我们使用SASS的初衷。更重要的是，SASS的嵌套编译出来的CSS，直接会影响页面的性能。 Mixin的缺点来看一个定义圆角的例子12345678910111213141516171819202122232425262728293031323334353637383940/*style.scss*/@mixin rounded &#123; border-radius: 5px;&#125;button &#123; @include rounded; background: #ccc; color: #222;&#125;.simple-form input &#123; @include rounded;&#125;.main-nav .item &#123; color: #fff; a:hover, a:active &#123; @include rounded; &#125;&#125;/*编译后的代码，这里是我格式化后的，方便阅读*//*style.css*/button &#123; border-radius: 5px; background: #ccc; color: #222;&#125;.simple-form input &#123; border-radius: 5px;&#125;.main-nav .item &#123; color: #fff;&#125;.main-nav .item a:hover,.main-nav .item a:active &#123; border-radius: 5px;&#125; 很明显更这样不够好，border-radius被重复输出了Mixin的黄金规则就是将相似的风格定义在一个@mixin中，另外Mixins主要是用于重用，而不是用来制定具体属性的值。换句话说，如果创建的Mixins没有传参数，那么就是一种错误的使用方式。正确的使用方式1234567@mixin rounded($radius:5px) &#123; /*这里给了参数一个默认值*/ -webkit-border-radius: $radius; -moz-border-radius: $radius; -o-border-radius: $radius; -ms-border-radius: $radius; border-radius: $radius;&#125; 继承的缺点sass的继承可以将相同样式的规则定义在一个类中，然后能通过@extend来调用。这样可以把相同的样式合并在一起我们试着把上面的@mixin rounde 替换成.rounded 1234567891011121314151617181920212223242526272829303132333435363738/*style.scss*/.rounded &#123; border-radius: 5px;&#125;button &#123; @extend .rounded; background: #ccc; color: #222;&#125;.simple-form input &#123; @extend .rounded;&#125;.main-nav .item &#123; color: #fff; a:hover, a:active &#123; @extend .rounded; &#125;&#125;/*编译后的代码*//*style.css*/.rounded,button,.simple-form input,.main-nav .item a:hover,.main-nav .item a:active &#123; border-radius: 5px;&#125;button &#123; background: #ccc; color: #222;&#125;.main-nav .item &#123; color: #fff;&#125; 可以看到代码清爽多了，这样可以解决@mixin致使样式多次重复出现的问题。但是@extend也有它的缺点,我们来看个例子1234567891011121314151617181920212223.button &#123; display: block; padding: 10px; background: green;&#125;.sidebar .signup .button &#123; margin-top: 20px;&#125;.registrantion,.remember-password &#123; .button &#123; margin-top: 33px; &#125;&#125;.edit-account .delete-area .button &#123; background-color: red; color: white;&#125;.article a &#123; @extend .button&#125; 期待编译后的代码是这样的12345.button .article a &#123; display: block; padding: 10px; background: green;&#125; 实际编译出来的代码是这样的1234567891011121314151617.button, .article a &#123; display: block; padding: 10px; background: green; &#125;.sidebar .signup .button, .sidebar .signup .article a, .article .sidebar .signup a &#123; margin-top: 20px; &#125;.registrantion .button, .registrantion .article a, .article .registrantion a,.remember-password .button,.remember-password .article a,.article .remember-password a &#123; margin-top: 33px; &#125;.edit-account .delete-area .button, .edit-account .delete-area .article a, .article .edit-account .delete-area a &#123; background-color: red; color: white; &#125; oh mygod!为什么是这样？.button类名可能用在不同处，有不同的容器包裹着，然而sass中的@extend无法判断引用哪个地方的.button，所以将不同地方的.button类名都引用了进来。这说明在使用继承时，你有足够的自信@extend的类名是唯一的 强大的’%’%只是一个占位符，只要不通过@extend调用，不会产生任何的代码。把上面的代码改成12345678910111213141516171819202122232425262728293031323334353637383940/*style.scss*/%button &#123; display: block; padding: 10px; background: green;&#125;.sidebar .signup .button &#123; margin-top: 20px;&#125;.registrantion,.remember-password &#123; .button &#123; margin-top: 33px; &#125;&#125;.edit-account .delete-area .button &#123; background-color: red; color: white;&#125;.article a &#123; @extend %button;&#125;/*style.css*/.article a &#123; display: block; padding: 10px; background: green; &#125;.sidebar .signup .button &#123; margin-top: 20px; &#125;.registrantion .button,.remember-password .button &#123; margin-top: 33px; &#125;.edit-account .delete-area .button &#123; background-color: red; color: white; &#125; 这样就得到了想要的结果 混合和继承的区别 @include主要是来调用@mixin定义的函数模块。在@mixin中可以定义一个相似功能样式，可以设置变量、定义参数、设置默认参数 @extend主要是来调用.class或%placeholders定义的模块，在.class或%placeholders中可以定义一个相同的样式，但是不能定义参数 @include每次调用相同的@mixin时，编译出来的css相同样式不会合并 @extend每次调用.class时，如果.class在样式出现多次，那么编译出来的可能不是需要的样式 @extend每次调用%placeholders时，编译出来的css相同样式会合并 Mixins与%placeholders的结合1234567891011%grid &#123; box-sizing: border-box; display: inline-block; padding-left: 1em; padding-right: 1em;&#125;@mixin grid($width: 1) &#123; @extend %grid; width: percentage($width);&#125; 上面的代码在编译是并不会产生任何代码，除非调用这个mixin函数123456789101112.grid-half &#123; @include grid(1 /2 );&#125;/*编译后的代码*/.grid-half &#123; box-sizing: border-box; display: inline-block; padding-left: 1em; padding-right: 1em; &#125;.grid-half &#123; width: 50%; &#125;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化之css]]></title>
    <url>%2F2017%2F12%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8Bcss.html</url>
    <content type="text"><![CDATA[今天在深入学习sass的时候看到了属性嵌套的问题，想到之前自己用sass写的代码，经过编译后，非常不利于维护和性能优化。于是在网上参考了许多资料，先总结一下。网上的不一定都正确，这里只做个简单的总结。具体情况要根据实际的情况而异。 加载性能减少文件体积，压缩代码减少阻塞加载，不要用 import style标签的相关调优把 Stylesheets 放在 HTML 页面头部：浏览器在所有的 stylesheets 加载完成之后，才会开始渲染整个页面，在此之前，浏览器不会渲染页面里的任何内容，页面会一直呈现空白。这也是为什么要把 stylesheet 放在头部的原因。如果放在 HTML 页面底部，页面渲染就不仅仅是在等待 stylesheet 的加载，还要等待 html 内容加载完成，这样一来，用户看到页面的时间会更晚。 对于 @import 和 link 两种加载外部 CSS 文件的方式：@import 就相当于是把 link 标签放在页面的底部，所以从优化性能的角度看，应该尽量避免使用 @import 命令 css缩写CSS 缩写可以让你用极少的代码定义一系列样式属性，这种做法可以极大程度的缩减代码量以达到提高性能的目的。 123div &#123; color: #ffffff ----&gt; #fff&#125; 12345678div &#123; margin-top: 10px; margin-right: 12px; margin-bottom: 10px; margin-left: 12px; /* 应该写成 */ margin: 10px 12px;&#125; css选择器相关子选择器123#toc &gt; li &#123; font-size: 18px;&#125; 按照我们惯常的理解，编译器应该先查找id为’#toc’的节点，然后在它的直接子节点中查找标签名为’li’的节点，然后绘制样式。实际上恰恰相反，浏览器是从右向左的匹配的。这里，浏览器会先查找所有的’li’节点，然后再做进一步的判断，如果它的父元素为’#toc’则匹配成功 后代选择器123#toc li &#123; font-size: 18px;&#125; 这个效率比之前的效率更慢，而且要慢很多。浏览器先便利所有的“li”节点，然后步步上溯其父节点，直到 DOM 结构的根节点（document），如果有某个节点的 id 为“toc”，则匹配成功，否则继续查找下一个“li”节点。 属性选择器1[hidden=&quot;true&quot;] &#123;...&#125; 这里的匹配规则是查找页面上的所有节点，如果有节点存在“hidden”属性，并且其属性值为“true”，则匹配成功。这是最耗时耗力的匹配，页面上的所有节点都需要进行匹配运算，这种规则应尽量避免。 id前面有标签名1button#hover &#123;...&#125; id 是全局唯一的，在匹配 CSS 选择器时浏览器定位到 id 是最快的，如果伴随有其他的非 id 的 selector，反而会影响匹配的效率。所以要不要在id选择器前面加标签名 class前面有标签名1button.active &#123;...&#125; ----&gt; button-active &#123;...&#125; 和上面的原理一样,页面上的 class 在全局范围内来讲应该是唯一的，用唯一的 Class 名称来定位一个节点往往比组合定位更加快捷。事实上，这种做法也可以避免由于开发修改页面元素的类型（Tag）而导致的样式失效的情况，做到样式与元素的分离，两者独立维护。 选择器嵌套选择器嵌套的越深匹配的越慢，一般选择器的嵌套不要超过5层。如果发现嵌套过深，这个时候应该用一个特殊的class来代替 尽量避免使用后代选择器而使用子选择器12ul li a ----&gt; ul &gt; li &gt;a /* 这里只是举个栗子，实际上用标签名做选择器是不好的 */ 利用css的继承机制1li &gt; a &#123; color: #000; &#125; ---&gt; li &gt; a &#123; color: inherit; &#125; css的许多属性都是可以继承的：Color， Font， Letter-spacing， Line-height， List-style， Text-align， Text-indent， Text-transform， White-space， Word-spacing 渲染性能慎重选择高消耗(绘制前需要浏览器进行大量计算)的样式: box-shadows border-radius transparency transform filters(性能杀手) 避免过分重排(Reflow)简单解释一下 Reflow：当元素改变的时候，将会影响文档内容或结构，或元素位置，此过程称为 Reflow。 导致reflow的情况：改变窗口大小，改变文字大小，添加/删除样式表，内容的改变，(用户在输入框中写入内容也会)，激活伪类，如:hover，操作class属性，脚本操作DOM，计算offsetWidth和offsetHeight，设置style属性 常见的重排元素 width height padding margin display border-width border top positon font-size float text-align overflow-y font-weight overflow left font-family line-height vertical-align right clear white-space bottom min-height 减少reflow对性能的影响的建议：1.不要一条一条地修改 DOM 的样式，预先定义好 class，然后修改 DOM 的 className2.把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改100次，然后再把它显示出来3.不要把 DOM 结点的属性值放在一个循环里当成循环里的变量4.尽可能不要修改影响范围比较大的 DOM5.为动画的元素使用绝对定位 absolute / fixed，这样不会影响其他元素的布局6.不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局7.避免设置大量的style属性，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow，所以最好是使用class属性8.动画实现的速度的选择。比如实现一个动画，以1个像素为单位移动这样最平滑，但是reflow就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多。9.不要使用table布局，因为table中某个元素旦触发了reflow，那么整个table的元素都会触发reflow。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围 避免过分重绘(Repaints)当元素改变的时候，将不会影响元素在页面当中的位置（比如 background-color, border-color, visibility），浏览器仅仅会应用新的样式重绘此元素，此过程称为 Repaint。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[let和const命令]]></title>
    <url>%2F2017%2F12%2Flet%E5%92%8Cconst%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。一道常见的题目1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[0](),...,a[9]() //var声明的变量是一个全局变量，每一次循环i的值都会改变，循环结束后i的值为10，所以最后输出的值为10 如果要改变输出结果，以前要这么写1234567891011121314151617181920var a = [];for (var i = 0; i &lt; 10; i++) &#123; !function(i)&#123; a[i] = function () &#123; console.log(i); &#125; &#125;(i) &#125;a[1]()//或者var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function (i) &#123; return function()&#123; console.log(i); &#125; &#125;(i)&#125;a[1]() 在ES61234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6]() //由于变量i是let声明的，当前的i只在本次循坏中有效，每一次循环的i其实都是一个新的变量 不存在变量提升。只要使用let或者const命令，变量是不会提升的12345console.log(foo) // 输出undefinedvar foo = 2console.log(bar) //报错ReferenceErrorlet bar = 2 暂时性死区ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。1234567891011if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 块级作用域与函数声明应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。123456&#123; let a = 'secret' let f = function()&#123; return a &#125;&#125; const命令const声明一个只读的常量。一旦声明，常量的值就不能改变。这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。1234const PI = 3.1415PI = 3 //TypeError: Assignment to constant variable.const foo //SyntaxError: Missing initializer in const declaration const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: "foo" is read-only 如果真的想将对象冻结，应该使用Object.freeze方法。12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[书籍推荐]]></title>
    <url>%2F2017%2F12%2F%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90.html</url>
    <content type="text"><![CDATA[前端优质书籍推荐《DOM JavaScript编程艺术》—-JavaScript最好的入门书，没有之一，这本书是帮助你了解如何将DOM、CSS和JavaScript连接起来的一本书。《JavaScript高级程序设计》—-JavaScript必读的一本精典，读完之后对JavaScript的理解和实践会上升非常大的一个台阶。《编写高质量代码——Web前端开发修炼之道》《HTML5和CSS3权威指南》《响应式Web设计：HTML5和CSS3实战》《JavaScript设计模式》]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件]]></title>
    <url>%2F2017%2F12%2F%E4%BA%8B%E4%BB%B6.html</url>
    <content type="text"><![CDATA[DOM0 事件和DOM2级在事件监听使用方式上有什么区别？DOM0级事件监听就是把一个方法赋值给一个元素的事件处理程序属性。将这些属性的值设置为一个函数，就可以指定事件处理程序。一个事件只能绑定一次，并且新方法会覆盖老方法。例如btn.onclick=function(){} DOM2级事件监听定义了两个方法用于处理指定和删除事件处理程序的操作：addEventListener、removeEventListener。所有的DOM节点都包含这两个方法，并且它们都接受三个参数：事件类型、事件处理方法、布尔参数。例如addEventListener、removeEventListener。可以选择按照冒泡的顺序处理还是捕获的顺序处理。 attachEvent与addEventListener的区别？1.参数个数不相同，这个最直观，addEventListener有三个参数，attachEvent只有两个，attachEvent添加的事件处理程序只能发生在冒泡阶段，addEventListener第三个参数可以决定添加的事件处理程序是在捕获阶段还是冒泡阶段处理（我们一般为了浏览器兼容性都设置为冒泡阶段）2.第一个参数意义不同，addEventListener第一个参数是事件类型（比如click，load），而attachEvent第一个参数指明的是事件处理函数名称（onclick，onload）3.事件处理程序的作用域不相同，addEventListener的作用域是元素本身，this是指的触发元素，而attachEvent事件处理程序会在全局变量内运行，this是window4.为一个事件添加多个事件处理程序时，执行顺序不同，addEventListener添加会按照添加顺序执行，而attachEvent添加多个事件处理程序时顺序无规律(添加的方法少的时候大多是按添加顺序的反顺序执行的，但是添加的多了就无规律了) 解释IE事件冒泡和DOM2事件传播机制？IE事件冒泡是指事件信息DOM树中接受事件的最下层开始向上传递直到根节点。DOM2事件传递机制是指先进行事件捕获后进行事件冒泡。事件信息从DOM根节点开始逐层下传到事件发生的目标元素，在达到目标元素后逐层冒泡上传至根节点 如何阻止事件冒泡？ 如何阻止默认事件？DOM浏览器：在DOM2级事件监听的第二个参数即匿名函数内使用e.stopPropagation()IE浏览器：window.event.cancelBubble = true;//停止冒泡window.event.returnValue = false;//阻止事件的默认行为]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dom操作]]></title>
    <url>%2F2017%2F12%2Fdom%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[dom对象的innerText和innerHTML有什么区别？ innerText不包含文档结构，只会包含对象的文本内容 innerHTML包含文档结构，标签属性等信息 elem.children和elem.childNodes的区别？ elem.childNodes包含HTML节点，文本节点，属性节点 elem.children只包含子HTML节点 查询元素有几种常见的方法？ES5的元素选择方法是什么?DOM0查询元素方法： document.getElementById(‘id’) document.getElementsByTagName(‘tagName’) document.getElementsByClassName(‘className’) DOM3(ES5)查询元素方法 document.querySelector(‘cssQuerySelector’) 如何创建一个元素？如何给元素设置属性？如何删除属性创建元素： createElement方法用来生成HTML元素节点。 createTextNode方法用来生成文本节点，参数为所要生成的文本节点的内容。 createDocumentFragment方法生成一个DocumentFragment对象。 setAttribute()方法用于设置元素属性；removeAttribute()用于删除元素属性 如何给页面元素添加子元素？如何删除页面元素下的子元素?创建元素createElement，用来生成HTML元素节点。1var newDiv = document.createElement("div") createTextNode，用来生成文本节点，参数为所要生成的文本节点的内容。12var newDiv = document.createElement("div")var newContent = document.createTextNode("Hello") createDocumentFragment,用来生成一个DocumentFragment对象。DocumentFragment对象是一个存在于内存的DOM片段，但是不属于当前文档，常常用来生成较复杂的DOM结构，然后插入当前文档。这样做的好处在于，因为DocumentFragment不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的DOM有更好的性能表现。 修改元素appendChild,在元素末尾添加元素insertBefore，在某个元素之前插入元素replaceChild，replaceChild()接受两个参数：要插入的元素和要替换的元素1newDiv.replaceChild(newElement, oldElement) 删除元素1parentNode.removeChild(childNode) clone元素cloneNode()方法用于克隆元素，方法有一个布尔值参数，传入true的时候会深复制，也就是会复制元素及其子元素（IE还会复制其事件），false的时候只复制元素本身 属性操作getAttribute()用于获取元素的attribute值createAttribute()方法生成一个新的属性对象节点，并返回它。setAttribute()方法用于设置元素属性removeAttribute()用于删除元素属性 上面的方法做的事情也可以通过类操作数组属性element.attributes来实现 location属性location属性返回一个只读对象，提供了当前文档的URL信息123456789101112131415161718192021222324// 假定当前网址为http://www.example.com:4097/path/a.html?x=111#part1document.location.href // "http://www.example.com:4097/path/a.html?x=111#part1"document.location.protocol // "http:"document.location.host // "www.example.com:4097"document.location.hostname // "www.example.com"document.location.port // "4097"document.location.pathname // "/path/a.html"document.location.search // "?x=111"document.location.hash // "#part1"document.location.origin //http://www.example.com:4097// 跳转到另一个网址document.location.assign('http://www.google.com')// 优先从服务器重新加载document.location.reload(true)// 优先从本地缓存重新加载（默认值）document.location.reload(false)// 跳转到另一个网址，但当前文档不保留在history对象中，即无法用后退按钮，回到当前文档document.location.replace('http://www.baidu.com')//虽然location属性返回的对象是只读的，但是可以将URL赋值给这个属性，网页就会自动跳转到指定网址。document.location = 'http://www.example.com'&lt;===&gt; document.location.href = 'http://www.example.com' dom常用API总结]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引用类型对象拷贝]]></title>
    <url>%2F2017%2F12%2F%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D.html</url>
    <content type="text"><![CDATA[引用类型有哪些？非引用类型有哪些引用类型包括：对象，数组，函数，正则。指的是那些保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针执行内存中的另一个位置，由该位置保存对象。基本类型值包括：数值，布尔值，null和undefined。指的是保存在栈内存中的简单数据段。 如下代码输出什么？为什么12345var obj1 = &#123;a:1, b:2&#125;;var obj2 = &#123;a:1, b:2&#125;;console.log(obj1 == obj2); //falseconsole.log(obj1 = obj2); //&#123;a:1,b:2&#125;(事实上是obj2的内容，实际传的值为obj2的指针)console.log(obj1 == obj2);//true 两者变量内存储的指针相等 如下代码输出什么？为什么12345678910111213141516171819var a = 1var b = 2var c = &#123; name: '饥人谷', age: 2 &#125;var d = [a, b, c]var aa = avar bb = bvar cc = cvar dd = da = 11b = 22c.name = 'hello'd[2]['age'] = 3console.log(aa) //1，传值赋值console.log(bb) //2，传值赋值console.log(cc) //&#123;name:"hello",age:3&#125;,传引用赋值console.log(dd) //[1, 2, &#123;name:"hello",age:3&#125;],前两个数组元素传值，第三个传引用 以下代码输出？为什么？123456789101112131415var a = 1var c = &#123; name: 'jirengu', age: 2 &#125;function f1(n)&#123; ++n&#125;function f2(obj)&#123; ++obj.age&#125;f1(a) f2(c) f1(c.age) console.log(a) //输出1，f1中相当于是声明了一个n=a，是把a的值赋给了n，++n变化的n的值，a不会发生变化。console.log(c) //输出&#123;name: "jirengu", age: 3&#125;，f2()中相当于obj=c。把c指向的地址赋值给了obj，所以++obj.age后，指向的地址内的值发生了变化，再打印c的时候打印的是指向的地址内的值，所以age变成3 过滤如下数组，只保留正数，直接在原数组上操作1234567891011var arr = [3,1,0,-1,-3,2,-5]function filter(array)&#123; for(var i = 0;i&lt;array.length;i++)&#123; if(array[i] &lt;= 0)&#123; array.splice(i,1) i-- &#125; &#125; return array&#125;filter(arr) //[3,1,2] 过滤如下数组，只保留正数，原数组不变，生成新数组1234567891011var arr = [3,1,0,-1,-3,2,-5]function filter(arr)&#123; var newArr = [] for(var i = 0;i &lt; arr.length;i++)&#123; if(arr[i] &gt; 0)&#123; newArr.push(arr[i]) &#125; &#125; return newArr&#125;filter(arr) 写一个深拷贝函数，用两种方式实现1234567891011121314151617181920212223var obj=&#123; a:1, b:2, c:&#123; d:1, e:2 &#125;&#125;function deepCopy1(obj)&#123; var result = &#123;&#125; for(var key in obj)&#123; result[key] = (typeof obj[key] === 'object')?deepCopy1(obj[key]):obj[key] &#125; return result&#125;deepCopy1(obj)function deepCopy2(obj)&#123; var result = &#123;&#125; result = JSON.parse(JSON.stringify(obj)) return result&#125;deepCopy2(obj)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数声明和函数表达式]]></title>
    <url>%2F2017%2F12%2F%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
    <content type="text"><![CDATA[函数声明和函数表达式有什么区别函数声明和函数表达式都能够定义一个函数。函数声明是指使用function关键字定义一个函数，不必放在调用的前面。函数表达式则是将函数的指针赋值给声明变量，本质上是一个表达式，使用时必须放在调用的前面。 什么是变量的声明前置？什么是函数的声明前置变量声明前置就是在一个作用域中，所有的变量都被放在作用域的顶部声明，举例：123456789console.log(a);var a=1;console(a);相当于var a;console.log(a);//undefineda=1;console.log(a);//1 函数声明前置把函数提升到作用域的顶部声明（函数表达式不可以），举例：12345678sayHello(); //hellosayHi(); //报错function sayHello()&#123; console.log("hello");&#125;var sayHi=function()&#123; console.log("hi");&#125; arguments 是什么arguments是一个类数组对象，类似数组的方式，可以通过下标的方式去获取值，但它本身不是数组，没有数组的一些特性，所以叫类数组对象。在函数内部，可以使用arguments对象获取到该函数的所有传入参数 函数的”重载”怎样实现重载是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。JS并不像其他强类型语言一样可以声明重载函数，若在原先声明的函数后再声明一个不同参数数量的函数(JS是弱语言，声明的函数不需要指明参数类型)，解析器会用后面声明的函数覆盖前面声明的函数。 1.在函数体内针对不同的参数调用执行相应的逻辑1234567function printInfo(name, age, sex)&#123; if(name)&#123; console.log(name)&#125; &#125; if(age)&#123; console.log(age) &#125; if(sex)&#123; console.log(sex) &#125; &#125; printInfo('xxx', 26) printInfo('xxx', 26, 'male') 2.使用arguments属性12345function printInfo(name, age, sex)&#123; console.log(arguments) &#125; printInfo('xxx', 26) printeInfo('xxx', 26, 'male') 立即执行函数表达式是什么？有什么作用立即执行函数的作用是隔离作用域，使被执行的函数内部的变量不会污染到外部，即外部不能访问函数内部的变量。参考]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型运算符流程控制语句]]></title>
    <url>%2F2017%2F12%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html</url>
    <content type="text"><![CDATA[JavaScript 定义了几种数据类型? 哪些是原始类型?哪些是复杂类型?原始类型和复杂类型的区别是什么?数据类型： 数值（number）:整数和小数（比如1和3.14） 字符串（string）：字符组成的文本（比如”Hello World”） 布尔值（boolean）：true（真）和false（假）两个特定值 undefined：表示“未定义”或不存在，即此处目前没有任何值 null：表示空缺，即此处应该有一个值，但目前为空 对象（object）：各种值组成的集合 Symbol: ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种。Symbol 是一个原始类型的值，不是对象。阮一峰es6入门 数值、字符串、布尔值称,Symbol(es6新增)为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了 将对象称为复杂类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。 至于undefined和null，一般将它们看成两个特殊值。 typeof和instanceof的作用和区别?typeof运算符返回一个对象的类型，可能返回三种基本类型以及function，undefined，以及object，是一个一元运算符。instanceof是一个二元运算符，用于判断某个变量是否是某个对象的实例。左边连接需要判断的变量，右边连接预期的类型，如果相符则返回true，不符则返回false。instanceof可以判断数组和对象。 如何判断一个变量是否是数字、字符串、布尔、函数JavaScript有三种方法，可以确定一个值到底是什么类型。 typeof运算符 instanceof运算符 Object.prototype.toString方法代码 toString()和valueOf()valueOf()：返回最适合该对象类型的原始值；toString(): 将该对象的原始值以字符串形式返回。 这两个方法一般是交由JS去隐式调用，以满足不同的运算情况。在数值运算里，会优先调用valueOf()，如a + b；在字符串运算里，会优先调用toString()，如alert(c)。JavaScript的toString()和valueOf()区别到底是什么 NaN是什么? 有什么特别之处?NaN，是Not a Number的缩写，在IEEE浮点数算术标准（IEEE 754）中定义，表示一些特殊数值（无穷与非数值（NaN）），为许多CPU与浮点运算器所采用。特别之处在于NaN和任何值都不相等，包括自己 如何把非数值转化为数值?Number: 如果是 Boolean 值，true 和 false 将分别被转换为 1 和0 如果是数字值，只是简单的传入和返回 如来是null 值，返回 0 如果是 undefined，返回NaN 如果是对象，则调用对象的 valueOf() 方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString() 方法，然后再次依照前面的规则转换返回的字符串值。 如果是字符串，遵循下列规则：1.如果字符串中只包含数字，则将其转换为十进制数值，即”1”会变 成1 ， “123”会变成123，而”011”会变成11（注意，前面的0被忽略了）2.如果字符串中包含有效的浮点格式， 如”1.1”，则将其转换为对应的浮点数值（同样，也会忽略前面的零）；3.如果字符串中包含有效的十六进制格式，例如”0xf”，则将其转换为相同大小的十进制整数值；4.如果字符串是空的（不包含任何字符） ，则将其转换为0；5.如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。 parseInt： 忽略字符串前面的空白字符，找到第一个非空白字符 如果第一个字符不是-或者数字返回NaN。如果是继续解析，直到非数值模式为止 0开头会当做八进制，0x开头会当做十六进制，但是可以指定第二个参数指定基数 parseFloat： parseFloat () 是从第一个字符（位置0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。举例来说，”22.34.5”将会被转换为22.34 。 除了第一个小数点有效之外， parseFloat () 与 parselnt() 的第二个区别在于它始终都会忽略前导的零。parseFloat() 可以识别前面讨论过的所有浮点数值格式，也包括十迸制整数格式，但十六进制格式的字符串则始终会被转换成0。由于 parseFloat() 只解析十进制值，因此它没有用第二个参数指定基数的用法。 ==与===有什么区别“==”包含了一个自动的隐式类型转换，规则如下： 如果一个是null，一个是undefined，那么相等 如果一个是数字，一个是字符串，先将字符串转为数字，然后比较 如果一个值是true/false则将其转为1/0比较 如果一个值是对象，一个是数字或字符串，则尝试使用valueOf和toString转换后比较 “===”则为严格相等，即类型与值必须全部相等,应尽量避免使用“==”。 break与continue有什么区别break：跳出循环，在一个循坏体内，一旦碰到break那么立即跳出循坏，后面所有的循坏都将不再执行。123456for(var i=1;i&lt;10;i++)&#123; if(i%4 == 0)&#123; break; &#125; console.log(i);打印的结果是（1,2,3） &#125; continue：跳出本次循环后，执行下次循坏123456for(var i=1;i&lt;10;i++)&#123; if(i%4 == 0)&#123; continue; &#125; console.log(i);打印的结果是（1,2,3,5,6,7,9） &#125; void 0 和 undefined在使用场景上有什么区别对于undefined,它的在全局作用域中，不会被重写，但在局部作用域中可以被重写。对于void可以给任何给定的表达式求值，并返回 undefined,并且 void 不可被重写，因此void 0是在局部作用域中替代undefined的最佳选择]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS相关概念]]></title>
    <url>%2F2017%2F12%2FJS%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5.html</url>
    <content type="text"><![CDATA[CSS和JS在网页中的放置顺序是怎样的？为了防止白屏与FOUC，CSS应放置于head标签内。为防止JS阻塞加载，JS应放置于body标签末尾。 简述网页的渲染机制 构建DOM树(DOM tree)：从上到下解析HTML文档生成DOM节点树（DOM tree），也叫内容树（content tree） 构建CSSOM(CSS Object Model)树：加载解析样式生成CSSOM树 执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件） 构建渲染树(render tree)：根据DOM树和CSSOM树,生成渲染树(render tree) 布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置 绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模块完成 相关文章 白屏和FOUC白屏浏览器的渲染需要先构建 DOM 和 CSSOM 树，假如 CSS 获取时间过长，就会导致 CSSOM 生成过久，浏览器只能等待，这时候就会出现长时间白屏，直到 DOM 和 CSSOM 构建完成。通常打开页面都会短暂白屏，因为 DOM 和 CSSOM 构建需要时间。 导致白屏的原因： 如果把样式放在底部,对于IE浏览器,由于DOM树过大，浏览器解析HTML文件时间过长但却没有解析CSS文件，在某些场景下(新窗口打开,刷新等)页面会出现白屏,而不是内容逐步展现 如果使用 @import 标签,即使 CSS 放入 link, 并且放在头部,也可能出现白屏 脚本会阻塞后面内容的呈现及其后组件的下载。对于图片和CSS, 在加载时会并发加载(如一个域名下同时加载两个文件). 但在加载 JavaScript 时,会禁用并发,并且阻止其他内容的下载. 所以把 JavaScript 放入页面顶部也会导致 白屏 现象 FOUC（Flash of Unstyled Content 无样式内容闪烁） 如果把样式放在底部,对于IE浏览器,在某些场景下(点击链接,输入URL,使用书签进入等),会出现 FOUC 现象(逐步加载无样式的内容,等CSS加载后页面突然展现样式).对于 Firefox 会一直表现出 FOUC Firefox浏览器经常出现FOUC现象与其渲染方式有关，Firefox在生成DOM后，将无样式内容展现，等到 CSSOM 生成了，再重绘渲染，这样就会看到一部分没样式的内容，然后再看到有样式的。这种分块分步的渲染 async和defer的作用是什么？有什么区别两者都是使脚本异步加载，没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。 async：加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 defer：加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 区别：defer:脚本延迟到文档解析和显示后执行，有顺序async:不保证顺序]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css综合]]></title>
    <url>%2F2017%2F12%2Fcss%E7%BB%BC%E5%90%88.html</url>
    <content type="text"><![CDATA[说一说你平时写代码遵守的编码规范 良好的命名规范ID和class的命名尽可能短，并符合语义。多个单词的拼接用 ‘-‘ 符号链接，尽量使用小写字母 代码缩写css代码缩写可以提高写代码的速度，精简代码质量。 利用CSS继承如果页面中父元素的多个子元素使用相同的样式，那最好把他们相同的样式定 义在其父元素上，让它们继承这些CSS样式。这样可以很好的维护代码，并且还可以减少代码量。 使用多重选择器可以合并多个CSS选择器为一个，如果他们有共同的样式的话。这样做不但代 码简洁且可节省时间和空间 适当的代码注释代码注释可以让别人更容易读懂代码，且合理的组织代码注释，可使得结构更加清晰。 选择更优的样式属性值CSS中有些属性采用不同的属性值，虽然达到的效果差不多，当性能上却存在着差异，如：区别在于border:0把border设为0px，虽然在页面上看不见，但按border默认值理解，浏览器依然对border-width/border-color进行了渲染，即已经占用了内存值。而border:none把border设为“none”即没有，浏览器解析“none”时将不作出渲染动作，即不会消耗内存值。所以建议使用border:none;同样的，display:none隐藏对象浏览器不作渲染，不占用内存。而visibility:hidden则会。 避免使用css hack 垂直居中有几种实现方式，给出代码范例绝对定位实现居中padding值实现居中添加伪元素实现居中display:table-celltable标签实现居中flex实现居中]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容]]></title>
    <url>%2F2017%2F12%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9.html</url>
    <content type="text"><![CDATA[什么是 CSS hackHack是针对不同的浏览器去写不同的CSS样式，从而让各浏览器能达到一致的渲染效果，那么针对不同的浏览器写不同的CSS CODE的过程，就叫CSS HACK，同时也叫写CSS Hack。 谈一谈浏览器兼容的思路 要不要做：产品的角度：（产品的受众、受众的浏览器比例、效果优先还是基本功能优先）成本的角度： (有无必要做某件事) 做到什么程度：让哪些浏览器支持哪些效果 如何做根据兼容需求选择技术框架/库(jquery)根据兼容需求选择兼容工具(html5shiv.js、respond.js、css reset、normalize.css、Modernizr) 列举5种以上浏览器兼容的写法 属性前缀法(即类内部Hack)：例如 IE6能识别下划线”_”和星号” “，IE7能识别星号” “，但不能识别下划线””，IE6~IE10都认识”\9”，但firefox前述三个都不能认识 123456.box &#123; color: red; _color: blue;/*IE6*/ *color: black;/*IE6,7*/ color: yellow;/*IE6-10*/&#125; 选择器前缀法(即选择器Hack)：比如IE6能识别*html .class{}，IE7能识别+html .class{} 条件注释 1&lt;!--[if IE 7]&gt;&lt;link rel="stylesheet" href="ie7.css" type="text/css"/&gt;&lt;![endif]--&gt; IE条件注释法结合选择器整体优化 利用normalize.css,统一所有浏览器样式 以下工具/名词是做什么的 条件注释条件注释是于HTML源码中被 IE 有条件解释的语句。条件注释可被用来向 IE提供及隐藏代码。 IE Hack针对IE浏览器编写不同的CSS的让IE能够在不同的正常渲染的过程 js 能力检测检测浏览器的能力检测目标不是检测特定的浏览器，而是检测浏览器的能力。这样，只需要检测浏览器是否支持特定的能力，就可以给出特定的解决方案。这一部分检测是解决浏览器兼容问题的主要检测。 html5shiv.jshtml5shiv.js是一个js库，用于解决IE9以下版本浏览器对HTML5新增标签不识别，并导致CSS不起作用的问题。 respond.jsRespond.js 是一个快速、轻量的 polyfill，用于为 IE6-8 以及其它不支持 CSS3 Media Queries 的浏览器提供媒体查询的 min-width 和 max-width 特性，实现响应式网页设计（Responsive Web Design）。 css reset重置浏览器的默认样式，更准确说就是通过重新定义标签样式，“覆盖”浏览器的CSS默认属性。 normalize.css先定义好一些CSS样式的同时保护有用的原生CSS样式，来让所有浏览器都按照同样的规则解释CSS。 ModernizrModernizr 是一个用来检测浏览器功能支持情况的 JavaScript 库。通过这个库我们可以检测不同的浏览器对于HTML5特性的支持情况。并以类标识的方式添加到标签中。 postCSSPostCSS是一个使用JavaScript插件来转换CSS的工具。能够达到兼容各种不同浏览器的效果，同时拥有很多插件。 一般在哪个网站查询属性兼容性？caniuse 查询css兼容性browserhacks查询Hack 的写法浏览器市场份额]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>浏览器兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浮动定位BFC边距合并]]></title>
    <url>%2F2017%2F12%2F%E6%B5%AE%E5%8A%A8%E5%AE%9A%E4%BD%8DBFC%E8%BE%B9%E8%B7%9D%E5%90%88%E5%B9%B6.html</url>
    <content type="text"><![CDATA[浮动元素有什么特征？对父容器、其他浮动元素、普通元素、文字分别有什么影响?特征：浮动元素会脱离正常的文档流，按照其外边距指定的位置相对于它的上一个块级元素（或父元素）显示浮动元素后面的块级元素的内容会向此浮动元素的外边距靠齐，但是边框和背景却忽略浮动元素而向上一个任意非浮动元素靠齐浮动元素后面的内联元素会向此浮动元素的外边距靠齐 float造成的影响：对其父元素的影响对于其父元素来说，元素浮动之后，它脱离当前正常的文档流，所以它也无法撑开其父元素，造成父元素的塌陷 对其兄弟元素（非浮动）的影响如果兄弟元素为块级元素，该元素会忽视浮动元素的而占据它的位置，并且元素会处在浮动元素的下层（并且无法通过z-index属性改变他们的层叠位置），但它的内部文字和其他行内元素都会环绕浮动元素。如果如果兄弟元素为内联元素，则元素会环绕浮动元素排列。 对其兄弟元素（浮动）的影响同一个方向的浮动元素：当一个浮动元素在浮动过程中碰到同一个方向的浮动元素时，它会紧跟在它们后面反方向的浮动元素：互不影响，位于同一条水平线上，当空间不够时会被挤下 清除浮动指什么？如何清除浮动？浮动会导致：（1）背景不能显示 （2）边框不能撑开 （3）margin 设置值不能正确显示清除浮动就是消除这些不良影响清除浮动可以通过使包含块的父元素变成BFC；添加伪元素，在伪元素设置clear:both来实现 有几种定位方式，分别是如何实现定位的，参考点是什么，使用场景是什么？ inherit，从父元素继承position属性的值，一般不用 static默认值,没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明 relative，生成相对定位的元素，相对于元素本身正常位置进行定位。属性值：left, top,right ,bottom，应用于对其自身进行细微调整 absolute，生成绝对定位的元素，相对于static定位以外的第一个祖先元素（offset parent）进行定位 fixed，生成绝对定位的元素，相对于浏览器窗口进行定位。属性值：left, top,right ,bottom z-index 有什么作用? 如何使用?z-index规定了元素在Z轴（距离用户远近）上的顺序，值越大(需要同属于同一个层叠上下文关系)则越靠近用户，表现就是元素在最上面。关于z-index详细说明 position:relative和负margin都可以使元素位置发生偏移?二者有什么区别position：relative可以使元素发生偏移，但是在文档流中，它仍然占据着原来的位置，所以其他同级元素的位置不会发生变化。负margin：通过负margin进行偏移的元素，它会放弃偏移前占据的空间，所以其他同级元素的位置发生了变化。 BFC 是什么？如何生成 BFC？BFC 有什么作用？举例说明BFC：块级格式化上下文，它是指一个独立的块级渲染区域，只有Block-level BOX参与，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。 CSS2.1中规定满足下列CSS声明之一的元素便会生成BFC。 根元素 float的值不为none overflow的值不为visible display的值为inline-block、table-cell、table-caption position的值为absolute或fixed 作用： 不和浮动元素重叠 如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个覆盖的现象，很多自适应的两栏布局就是这么做的。 清除元素内部浮动 只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了 嵌套元素Margin边距折叠问题的解决 按照BFC的定义，只有同属于一个BFC时，两个元素才有可能发生垂直Margin的重叠，这个包括相邻元素，嵌套元素，只要他们之间没有阻挡(例如没有边框，非空内容，padding等)就会发生margin重叠。 因此要解决margin重叠问题，只要让它们不在同一个BFC就行了，只要把父元素设为BFC就可以了。这样子元素的margin就不会和父元素的margin发生重叠了 在什么场景下会出现外边距合并？如何合并？如何不让相邻元素外边距合并？给个父子外边距合并的范例场景： 同一个BFC，且同处于普通流中的垂直相邻元素外边距合并。 父子元素的外边距合并。 空元素的外边距合并。 合并规则： 两个margin都是正值的时候，取两者的最大值； 当 margin 都是负值的时候，取的是其中绝对值较大的，然后，从0位置，负向位移； 当有正有负的时候，先取出负 margin 中绝对值中最大的，然后，和正 margin 值中最大的 margin 相加。 所有毗邻的margin要一起参与运算，不能分步进行。 不让相邻元素外边距合并的方法： 被非空内容、padding、border 或 clear 分隔开。 不在一个普通流中或一个BFC中。 margin在垂直方向上不毗邻。 123&lt;div&gt; &lt;p style="margin-top:30px"&gt;这是一段文字&lt;/p&gt;&lt;/div&gt; 相关文章]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css常见样式2]]></title>
    <url>%2F2017%2F12%2Fcss%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F2.html</url>
    <content type="text"><![CDATA[text-align: center的作用是什么，作用在什么元素上？能让什么元素水平居中text-align: center;的作用是令元素水平居中，IE6/7及IE8混杂模式中，text-align:center可以使块级元素也居中对齐。其他浏览器中，text-align:center仅作用于行内内容上。 IE 盒模型和W3C盒模型有什么区别?IE盒模型的宽高：包含了border,padding,content的值。W3C盒模型的宽高：以content的宽度高度作为width和height *{ box-sizing: border-box;}的作用是什么？设置为IE盒模型，IE盒模型的宽高包含了border,padding,content的值。使用该属性，设置盒模型的宽高时，不用去考虑内部的计算，因为设置border，padding也不会增加该盒模型的宽高。 line-height: 2和line-height: 200%有什么区别?line-height: 2：设置行高为元素本身字体大小的两倍，无论字体大小，后代都会继承两倍行高这个关系line-height: 200%：设置行高为其父元素字体大小的两倍，后代只会继承固定的行高，不会继承两倍的行高。 inline-block有什么特性？如何去除缝隙？高度不一样的inline-block元素如何顶端对齐?具有内联和块级元素的特性：不会占据一整行；可以设置宽高，margin,padding 如何去除缝隙：标签不换行；设置父元素字体大小为0，然后单独设置字体大小如何顶端对齐：vertical-align: top; CSS sprite 是什么?CSSSprites在国内很多人叫css精灵，是一种网页图片应用处理方式。它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去,再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位。 其优点在于： 减少网页的http请求，提高性能，这也是CSS Sprites最大的优点，也是其被广泛传播和应用的主要原因； 减少图片的字节：多张图片合并成1张图片的字节小于多张图片的字节总和； 减少了命名困扰：只需对一张集合的图片命名，不需要对每一个小元素进行命名提高制作效率； 更换风格方便：只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变，维护起来更加方便。 其缺点在于： 图片合成比较麻烦； 背景设置时，需要得到每一个背景单元的精确位置； 维护合成图片时，最好只是往下加图片，而不要更改已有图片 让一个元素”看不见”有几种方式？有什么区别?123456#E &#123; opacity: 0;/* 变透明，仍占据位置*/ visibility: hidden;/*消失 占位置*/ display: none;/*消失 不占位置*/ background-color: rgba(0, 0, 0, 0);/*背景透明*/&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css常见样式]]></title>
    <url>%2F2017%2F12%2Fcss%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F.html</url>
    <content type="text"><![CDATA[块级元素和行内元素分别有哪些?有哪些区别？块级元素: div , p , form, ul, li , ol, dl, form, address, fieldset, hr, menu, table行内元素：span, strong, em, br, img , input, label, select, textarea, cite 区别： 块级元素会独占一行，其宽度自动填满其父元素宽度 行内元素不会独占一行，相邻的行内元素会排列在同一行里，直到一行排不下，才会换行，其宽度随元素的内容而变化 块级元素可以设置 width, height属性，行内元素设置width, height无效 块级元素可以设置margin 和 padding。行内元素可以设置margin和padding但是水平方向有效，竖直方向无效 什么是 CSS 继承? 哪些属性能继承，哪些不能？应用样式的元素的后代会继承样式的某些属性，比如颜色和字号。这种特点称作CSS继承。不可继承的：display、margin、border、padding、background、height、min-height、max- height、width、min-width、max-width、overflow、position、left、right、top、 bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、 page-bread-before和unicode-bidi。所有元素可继承：visibility和cursor。内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、 font-family、font-size、font-style、font-variant、font-weight、text- decoration、text-transform、direction。块级元素可继承：text-indent和text-align。列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。表格元素可继承：border-collapse。 如何让块级元素水平居中？如何让行内元素水平居中?块级元素水平居中一般使用margin: 0 auto;实现。行内元素水平居中一般使用text-align: center;实现。更多居中方法参考：css水平居中，垂直居中 单行文本溢出加 …如何实现?12345#E&#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; 多行文本溢出加…参考：如何实现单行文本/多行文本溢出的省略 px, em, rem 有什么区别?px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。(引自CSS2.0手册)em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(引自CSS2.0手册)rem是CSS3新增的一个相对单位（rootem，根em），区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。 解释下面代码的作用?为什么要加引号? 字体里\5b8b\4f53代表什么?123body&#123; font: 12px/1.5 tahoma,arial,'Hiragino Sans GB','\5b8b\4f53',sans-serif;&#125; 作用：定义body标签内的所有字体大小为12px，1.5倍行距，依次尝试tahoma,arial,’Hiragino Sans GB’,’\5b8b\4f53’,sans-serif 这几种字体，取较前的设定为所用字体。为什么要加引号：因为字体名称内部有空格，不加引号易引起歧义。\5b8b\4f53：‘宋体’两个字的Unicode 编码，在此可以代替‘宋体’两个字。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css选择器]]></title>
    <url>%2F2017%2F12%2Fcss%E9%80%89%E6%8B%A9%E5%99%A8.html</url>
    <content type="text"><![CDATA[class 和 id 的使用场景?Html中的“类”（class）可以赋予给多个不同标签，而id每篇html文档只可以存在一次，因此class多用于某种统一的样式，而id多用于“仅此一种”的样式。实践上，对于样式而言，我们常常采用class而不是id。 CSS选择器常见的有几种? 基础选择器 1.通配符选择器 * { color:red } 2.id选择器 3.类选择器 4.标签选择器 组合选择器 1.多元素选择器：以,分隔，表示同时匹配多个选择器对应的元素 2.后代选择器：以空格分隔 属性选择器 1.E[attr]：筛选出所有具有属性名为attr的属性的元素 2.E[attr=value]：筛选出所有属性attr的值为vlaue的元素 伪类选择器 1.E:link：未被访问时的样式 2.E:visited：已经被访问后的样式 3.E:hover：鼠标悬停在a链接之上的样式 4.E:active：鼠标按下但未释放时的样式 5.E:first-child：父元素的各类标签中第一个子元素且必须符合指定类型（为E） 6.E:nth-child：匹配其父元素的第n个子元素 伪元素选择器 1.E:before：在E元素之前插入的内容 2.E:after：在E元素之后插入的内容 选择器的优先级是怎样的?对于复杂场景如何计算优先级？!important &gt; 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性 优先级计算方法：先数 id选择器数量，如果id选择器数量多的选择器权重高,如果id选择器数量相同，再数类选择器数量，最后数标签。 a:link, a:hover, a:active, a:visited 的顺序是怎样的？ 为什么？a:link：选择未被访问的链接，并设置其样式a:hover：选择鼠标指针浮动在其上的元素，并设置其样式a:active：选择活动链接，并设置其样式a:visited：选择已访问的链接，并设置其样式 在W3C规范中，也规定了链接的声明顺序：在 CSS 定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。 所以正确的顺序为：a:link、a:visited、a:hover、a:active 列出你知道的选择器E:first-child 匹配元素E的第一个子元素E:link 匹配所有未被点击的链接E:visited 匹配所有已被点击的链接E:active 匹配鼠标已经其上按下、还没有释放的E元素E:hover 匹配鼠标悬停其上的E元素E:enabled 匹配表单中可用的元素E:disabled 匹配表单中禁用的元素E:checked 匹配表单中被选中的radio或checkbox元素E::selection 匹配用户当前选中的元素E:nth-child(n) 匹配其父元素的第n个子元素，第一个编号为1E:nth-last-child(n) 匹配其父元素的倒数第n个子元素，第一个编号为1E:nth-of-type(n) 与:nth-child()作用类似，但是仅匹配使用同种标签的元素E:nth-last-of-type(n) 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素E:last-child 匹配父元素的最后一个子元素，等同于:nth-last-child(1)E:first-of-type 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)E:last-of-type 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)E:only-child 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)E:only-of-type 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)E:not(selector) 匹配不符合当前选择器的任何元素 div:first-child、div:first-of-type、div :first-child和div :first-of-type的作用和区别 （注意空格的作用）:first-child选择器是选择父元素的第一个子元素，而:first-of-type选择器则是选择第一个这个类/这个标签的子元素。而空格无非是后代选择器而已，所以这四个选择器的意义分别是： div:first-child：是第一个元素的 div 标签div:first-of-type：第一个 div 标签div :first-child：div 标签下的第一个元素div :first-of-type：div 标签下每个标签的第一个元素 范例： 12345678910111213&lt;style&gt;.item1:first-child&#123; color: red;&#125;.item1:first-of-type&#123; background: blue;&#125;&lt;/style&gt;&lt;div class="ct"&gt; &lt;p class="item1"&gt;aa&lt;/p&gt; &lt;h3 class="item1"&gt;bb&lt;/h3&gt; &lt;h3 class="item1"&gt;ccc&lt;/h3&gt;&lt;/div&gt; aabbccc .item1:first-child{ color: red; } .item1:first-of-type{ background: blue; } 解释：.item1:first-child选中了item1类中第一个元素，所以内容为“aa”的p标签变红色了。.item1:first-of-type选中了item1类中所有的标签的第一个元素，所以p标签和第一个h3标签的背景变蓝了。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css基础]]></title>
    <url>%2F2017%2F12%2Fcss%E5%9F%BA%E7%A1%80.html</url>
    <content type="text"><![CDATA[CSS的全称是什么?层叠样式表（英语：Cascading Style Sheets，简写CSS），一种用来为结构化文档（如HTML文档或XML应用）添加样式（字体、间距和颜色等）的计算机语言，由W3C定义和维护。 CSS有几种引入方式? link 和@import 有什么区别?CSS有几种引入方式四种，分别为行内样式，内嵌样式和外联样式以及@import link 和@import 有什么区别 link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。 link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。所以有时候浏览@import加载CSS的页面时开始会没有样式（就是闪烁）。 link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。 link支持使用Javascript控制DOM去改变样式；而@import不支持。 以下这几种文件路径分别用在什么地方，代表什么意思? css/a.css相对路径，当前目录下css文件夹内a.css文件 ./css/a.css相对路径，同级目录下css文件夹内a.css文件 b.css相对路径，与当前文档同级目录下b.css文件 ../imgs/a.png相对路径，上级文件夹下imgs文件夹内a.png文件 /Users/hunger/project/css/a.css绝对路径，根目录下对应路径的文件 /static/css/a.css绝对路径，根目录下对应路径的文件 http://cdn.jirengu.com/kejian1/8-1.png绝对路径，表示饥人谷该网站kejian1目录下的名为8-1.png的图片地址 列出5条以上html和 css 的书写规范 一次缩进2个空格，不要使用 tab 或者混合 tab 和空格的缩进。 HTML 元素名称，属性，属性值（除非 text/CDATA），CSS 选择器，属性，属性值应该使用小写。 结尾切勿加空格空格不仅多余，而且在比较代码时会更麻烦。 在 HTML 中通过指定编码方式，CSS 中不需要指定，因为默认是 UTF-8。 使用注释来解释代码：包含的模块，功能以及优点。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[form表单]]></title>
    <url>%2F2017%2F12%2Fform%E8%A1%A8%E5%8D%95.html</url>
    <content type="text"><![CDATA[form表单有什么作用？有哪些常用的input 标签，分别有什么作用？表单在网页中主要负责数据采集功能。一个表单有三个基本组成部分： 表单标签：这里面包含了处理表单数据所用CGI程序的URL以及数据提交到服务器的方法。 表单域：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等。 表单按钮：包括提交按钮、复位按钮和一般按钮；用于将数据传送到服务器上的CGI脚本或者取消输入，还可以用表单按钮来控制其他定义了处理 常见的input标签: 标签 作用 text 单行文本框 password 密码框 checkbox 多选输入框 radio 单选按钮 file 上传文件 hidden 隐藏域 submit 数据提交按钮 button 普通按钮 post 和 get 方式的区别 GET提交：请求的数据会附在URL之后(就是把数据放置在HTTP协议头中)，以?分割URL和传输数据，多个参数用&amp;连接。如果数据是英文字母数字，原样发送，如果是空格，转换为+，如果是中文其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中%XX中的XX为该符号以16进制表示的ASCII。示例：点击提交,地址跳转为 POST提交：把提交的数据放置在是HTTP包的包体中。示例：点击提交后信息并没有显示在地址栏里面因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变。 传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制 而在实际开发中存在的限制主要有： GET: 特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2K+35。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。 POST: 由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。 name属性 作为可与服务器交互数据的HTML元素的服务器端的标示，比如input、select、textarea、和button等。我们可以在服务器端根据其Name通过Request.Params取得元素提交的值。 HTML元素Input type=’radio’分组，我们知道radio button控件在同一个分组类，check操作是mutex的，同一时间只能选中一个radio，这个分组就是根据相同的Name属性来实现的。 建立页面中的锚点，我们知道&lt;a href=&quot;URL&quot;&gt;link&lt;/a&gt;是获得一个页面超级链接，如果不用href属性，而改用Name，如：&lt;a name=&quot;PageBottom&quot;&gt;&lt;/a&gt;，我们就获得了一个页面锚点。 作为对象的Identity，如Applet、Object、Embed等元素。比如在Applet对象实例中，我们将使用其Name来引用该对象。 在IMG元素和MAP元素之间关联的时候，如果要定义IMG的热点区域，需要使用其属性usemap，使usemap=”#name”(被关联的MAP元素的Name)。 某些特定元素的属性，如attribute，meta和param。例如为Object定义参数或Meta中。 radio如何分组在同一个分组里，name属性要有相同的值。12&lt;input type="radio" name="gender" value="male"&gt;&lt;input type="radio" name="gender" value="female"&gt; placeholder 属性有什么作用?可以在文本输入框内显示默认的提示字符 type=hidden隐藏域有什么作用? 举例说明 隐藏数据一起发送给服务器。 作为LocalStorage的替代品。 当有多个submit按钮时，可以用于确认是哪个按钮提交的表单。 可以用于联系多个表单。 作为全局变量使用。 作为父窗口的隐藏域，对小窗口传参。 input type=’submit’ 和type=’button’ 有什么区别在一个页面上话一个按钮有四种方法：1234567&lt;!-- 这就是一个按钮。如果你不写javascript 的话，按下去什么也不会发生。 --&gt;&lt;input type="button"&gt;&lt;!-- 这样的按钮用户点击之后会自动提交 form，除非你写了javascript 阻止它。 --&gt;&lt;input type="submit" /&gt;&lt;!-- 这个按钮放在 form 中也会点击自动提交，比前两个的优点是按钮的内容不光可以有文字，还可以有图片等多媒体内容。（当然，前两个用图片背景也可以做到）。它的缺点是不同的浏览器得到的 value 值不同；可能还有其他的浏览器兼容问题 --&gt;&lt;button&gt;&lt;!-- 其他标签，例如 a, img, span, div，然后用图片把它伪装成一个按钮。 --&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端利用动态rem实现自适应布局（一）]]></title>
    <url>%2F2017%2F12%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%88%A9%E7%94%A8%E5%8A%A8%E6%80%81rem%E5%AE%9E%E7%8E%B0%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[什么是rem这个单位代表根元素的 font-size 大小（例如 &lt;html&gt; 元素的font-size）当用在根元素的font-size上面时 ，它代表了它的初始值(译者注:默认的初始值是html的默认的font-size大小,比如当未在根元素上面设置font-size大小的时候,此时的1rem==1em,当设置font-size=2rem的时候,就使得页面中1rem的大小相当于html的根字体默认大小的2倍,当然此时页面中字体的大小也是html的根字体默认大小的2倍)。 自适应的精髓就是让盒子的大小，间距等与视窗的大小相关。如何用rem做到这一点？我们可以通过js来获取视窗的宽度，然后给html一个font-size值，让两者关联起来 有这样一个需求。有四个div盒子，每个盒子的宽度是高度的两倍，盒子中间的间距是周围间距的两倍，效果如下。并且在不同屏幕宽度小都能呈现出相同的效果 123var pageWidth = window.innerWidth document.write(`&lt;style&gt;html&#123;font-size:$&#123;pageWidth/10&#125;px;&#125;&lt;/style&gt;`) &lt;/script&gt; 12345678&lt;body&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt;box1&lt;/div&gt; &lt;div class="child"&gt;box2&lt;/div&gt; &lt;div class="child"&gt;box3&lt;/div&gt; &lt;div class="child"&gt;box4&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 12345678910111213141516171819* &#123; margin: 0; padding: 0; box-sizing: border-box; &#125;body &#123; font-size: 16px; &#125;clear::after &#123; content: ''; display: block; clear: both; &#125;.child &#123; width: 4rem; height: 2rem; margin: 0.5rem 0.5rem; float: left; background: #8e8585; &#125; 这样有一个问题，我每次都要计算才能得到给多少rem值，这样很麻烦。我们可以通多scss里面的函数解决这个问题。123456789101112131415161718192021@function px2rem($px)&#123; @return $px/$designWidth *10+ rem&#125;$designWidth : 320;* &#123;margin: 0;padding: 0;box-sizing: border-box;&#125;body &#123;font-size: 16px;&#125;clear::after&#123; content: ''; display: block; clear: both;&#125;.child &#123; width: px2rem(128); height: px2rem(64); margin: px2rem(16) px2rem(16); float: left; background: #8e8585;&#125; 结尾：这只是一个简单的利用动态rem实现自适应的思路，更多的细节，需要持续关注。附上一篇大漠老师的文章使用Flexible实现手淘H5页面的终端适配]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>响应式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML知识]]></title>
    <url>%2F2017%2F12%2FHTML%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[HTML、XML、XHTML 有什么区别HTML、XML和XHTML都是标准通用标记语言的一个子集。 HTML被设计用来显示数据，其焦点是数据的外观,是最早写网页的语言，但是由于时间早，规范不是很好，大小写混写且编码不规范； XML被设计用来传输和存储数据，其焦点是数据的内容。 XHTML是更严格更纯净的 HTML 版本，是作为一种 XML 应用被重新定义的 HTML，设计的目的是为了取代HTML以适应未来网络更多的需求。 它们都可以用来开发网页，但就目前来看，网页开发中HTML还是占绝对的主流，现在最新版本HTML5也备受推崇。可拓展标记语言XML广泛运用于各种应用程序中数据的存储（例如各种配置文件）和应用程序间的数据传输，可以说是一项必须掌握的技术。至于可扩展超文本标记语言XHTML，在2009年W3C已经宣布停止了对XHTML2的开发，转而大力支持HTML5。 怎样理解 HTML 语义化语义化的HTML就是写出的HTML代码，根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。语义化有助于： 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重。 在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看。 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 怎样理解内容与样式分离的原则 写 HTML 仅处理内容，只考虑 HTML 的结构和语义化，避免出现属性样式。 写 JS 的时候，尽量不使用 JS直接操作样式。 页面展现的所有样式，都由CSS来负责实现。 有哪些常见的meta标签12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- 关键字，搜所引擎 SEO --&gt;&lt;!-- 关键字，搜所引擎 SEO --&gt;&lt;meta http-equiv="keywords" content="关键字1,关键字2,..."&gt; &lt;!-- 页面描述 --&gt;&lt;meta http-equiv="description" content="网页描述"&gt; &lt;!-- content的取值为webkit,ie-comp,ie-stand之一，区分大小写，分别代表用webkit内核，IE兼容内核，IE标准内核。 --&gt;&lt;meta name="renderer" content="webkit|ie-comp|ie-stand"&gt;&lt;!-- 若页面需默认用极速核，增加标签： --&gt;&lt;meta name="renderer" content="webkit"&gt;&lt;!-- 若页面需默认用ie兼容内核，增加标签： --&gt;&lt;meta name="renderer" content="ie-comp"&gt;&lt;!-- 若页面需默认用ie标准内核，增加标签： --&gt;&lt;meta name="renderer" content="ie-stand"&gt;&lt;!-- 如果安装了GCF，则使用GCF来渲染页面，如果没有安装GCF，则使用最高版本的IE内核进行渲染。X-UA-Compatible：这是个是IE8的专用标记,用来指定IE8浏览器去模拟某个特定版本的IE浏览器的渲染方式(比如人见人烦的IE6)，以此来解决部分兼容问题。 --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" &gt;&lt;!-- 强制页面在当前窗口以独立页面显示。 --&gt;&lt;meta http-equiv="Window-target" content="_top"&gt;&lt;!-- 自动刷新，并指向新的页面 --&gt;&lt;meta http-equiv="Refresh" content="2；URL=http://"&gt;&lt;!-- 禁止浏览器缓存 --&gt;&lt;!-- 是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出用法： --&gt;&lt;meta http-equiv="pragram" content="no-cache"&gt; &lt;!-- 清除缓存（再访问这个网站要重新下载！） --&gt;&lt;meta http-equiv="cache-control" content="no-cache, must-revalidate"&gt; &lt;!-- 设定网页的到期时间 --&gt;&lt;meta http-equiv="expires" content="0"&gt; &lt;!-- 手机端 --&gt;&lt;meta name="format-detection" content="telphone=no, email=no"/&gt;&lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;&lt;meta name="apple-mobile-web-app-status-bar-style" content="black"/&gt;&lt;!-- 设置苹果工具栏颜色 --&gt;&lt;!-- 不让百度转码 --&gt;&lt;meta http-equiv="Cache-Control" content="no-siteapp" /&gt;&lt;!-- 不缓存 --&gt;&lt;meta http-equiv="cache-control" content="no-cache" /&gt;&lt;!-- 初始化设备 --&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimal-ui" /&gt;&lt;!-- 网站开启对iphone私有 web app 程序的支持 --&gt;&lt;meta content="yes" name="apple-mobile-web-app-capable" /&gt;&lt;!-- 改变顶部状态条的颜色 iphone私有的属性--&gt;&lt;meta content="black" name="apple-mobile-web-app-status-bar-style" /&gt; 文档声明的作用?严格模式和混杂模式指什么?&lt;!doctype html&gt;的作用文档声明的作用文档声明指出阅读程序应该用什么规则集来解释文档中的标记。在web文档的情况下，“阅读程序”通常是浏览器或者校验器这样的一个程序，“规则”则是w3c所发布的一个文档类型定义（dtd）中包含的规则。每个dtd都包括一系列标记、attributes和properties，它们用于标记web文档的内容；此外还包括一些规则，它们规定了哪些标记能出现在其他哪些标记中。每个web建议标准（比如html 4 frameset和xhtml 1.0 transitional）都有自己的dtd。假如文档中的标记不遵循doctype声明所指定的dtd，这个文档除了不能通过代码校验之外，还有可能无法在浏览器中正确显示。对于标记不一致的问题，浏览器相较于校验器来说更宽容。但是，不正确的doctype声明经常导致网页不正确显示，或者导致它们根本不能显示。 严格模式和混杂模式指什么严格模式：又称标准模式，是指浏览器按照 W3C 标准解析代码。 混杂模式：又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码。 如何区分：浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。 如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。（严格 DTD ——严格模式）包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。（DTD不存在或者格式不正确——混杂模式）HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。（ HTML5 没有严格和混杂之分）意义：严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，每个浏览器都有自己的解析模式。 &lt;!doctype html&gt;的作用声明文档的解析类型(document.compatMode)，避免浏览器的怪异模式 document.compatMode：BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。CSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面。 这个属性会被浏览器识别并使用，但是如果你的页面没有DOCTYPE的声明，那么compatMode默认就是BackCompat,这也就是绝望和黑暗的开始 – 浏览器按照自己的方式解析渲染页面，那么，在不同的浏览器就会显示不同的样式。如果你的页面添加了&lt;!DOCTYPE html&gt;那么，那么就等同于开启了标准模式，那么浏览器就得老老实实的按照W3C的标准解析渲染页面，这样一来，你的页面在所有的浏览器里显示的就都是一个样子了。这就是&lt;!DOCTYPE html&gt;的作用。 浏览器乱码的原因是什么？如何解决造成html网页乱码原因主要是html源代码内中文字内容与html编码不同造成。但无论是哪种情况造成乱码解决方法都是在网页开始时候设置网页编码 常见的浏览器有哪些，什么内核 浏览器 市场占有率 内核 Chrome 58.64% WebKit/Chromium引擎 Internet Explorer 18.95% Trident Firefox 11.79% Gecko Edge 5.61% Trident Safari 3.37% WebKit Opera 1.18% Presto]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
</search>
