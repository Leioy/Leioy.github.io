<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[css选择器]]></title>
    <url>%2F2017%2F12%2Fcss%E9%80%89%E6%8B%A9%E5%99%A8.html</url>
    <content type="text"><![CDATA[class 和 id 的使用场景?Html中的“类”（class）可以赋予给多个不同标签，而id每篇html文档只可以存在一次，因此class多用于某种统一的样式，而id多用于“仅此一种”的样式。实践上，对于样式而言，我们常常采用class而不是id。 CSS选择器常见的有几种? 基础选择器 1.通配符选择器 * { color:red } 2.id选择器 3.类选择器 4.标签选择器 组合选择器 1.多元素选择器：以,分隔，表示同时匹配多个选择器对应的元素 2.后代选择器：以空格分隔 属性选择器 1.E[attr]：筛选出所有具有属性名为attr的属性的元素 2.E[attr=value]：筛选出所有属性attr的值为vlaue的元素 伪类选择器 1.E:link：未被访问时的样式 2.E:visited：已经被访问后的样式 3.E:hover：鼠标悬停在a链接之上的样式 4.E:active：鼠标按下但未释放时的样式 5.E:first-child：父元素的各类标签中第一个子元素且必须符合指定类型（为E） 6.E:nth-child：匹配其父元素的第n个子元素 伪元素选择器 1.E:before：在E元素之前插入的内容 2.E:after：在E元素之后插入的内容 选择器的优先级是怎样的?对于复杂场景如何计算优先级？!important &gt; 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性 优先级计算方法：先数 id选择器数量，如果id选择器数量多的选择器权重高,如果id选择器数量相同，再数类选择器数量，最后数标签。 a:link, a:hover, a:active, a:visited 的顺序是怎样的？ 为什么？a:link：选择未被访问的链接，并设置其样式a:hover：选择鼠标指针浮动在其上的元素，并设置其样式a:active：选择活动链接，并设置其样式a:visited：选择已访问的链接，并设置其样式 在W3C规范中，也规定了链接的声明顺序：在 CSS 定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。 所以正确的顺序为：a:link、a:visited、a:hover、a:active 列出你知道的选择器E:first-child 匹配元素E的第一个子元素E:link 匹配所有未被点击的链接E:visited 匹配所有已被点击的链接E:active 匹配鼠标已经其上按下、还没有释放的E元素E:hover 匹配鼠标悬停其上的E元素E:enabled 匹配表单中可用的元素E:disabled 匹配表单中禁用的元素E:checked 匹配表单中被选中的radio或checkbox元素E::selection 匹配用户当前选中的元素E:nth-child(n) 匹配其父元素的第n个子元素，第一个编号为1E:nth-last-child(n) 匹配其父元素的倒数第n个子元素，第一个编号为1E:nth-of-type(n) 与:nth-child()作用类似，但是仅匹配使用同种标签的元素E:nth-last-of-type(n) 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素E:last-child 匹配父元素的最后一个子元素，等同于:nth-last-child(1)E:first-of-type 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)E:last-of-type 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)E:only-child 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)E:only-of-type 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)E:not(selector) 匹配不符合当前选择器的任何元素 div:first-child、div:first-of-type、div :first-child和div :first-of-type的作用和区别 （注意空格的作用）:first-child选择器是选择父元素的第一个子元素，而:first-of-type选择器则是选择第一个这个类/这个标签的子元素。而空格无非是后代选择器而已，所以这四个选择器的意义分别是： div:first-child：是第一个元素的 div 标签div:first-of-type：第一个 div 标签div :first-child：div 标签下的第一个元素div :first-of-type：div 标签下每个标签的第一个元素 范例： 12345678910111213&lt;style&gt;.item1:first-child&#123; color: red;&#125;.item1:first-of-type&#123; background: blue;&#125;&lt;/style&gt;&lt;div class="ct"&gt; &lt;p class="item1"&gt;aa&lt;/p&gt; &lt;h3 class="item1"&gt;bb&lt;/h3&gt; &lt;h3 class="item1"&gt;ccc&lt;/h3&gt;&lt;/div&gt; aabbccc .item1:first-child{ color: red; } .item1:first-of-type{ background: blue; } 解释：.item1:first-child选中了item1类中第一个元素，所以内容为“aa”的p标签变红色了。.item1:first-of-type选中了item1类中所有的标签的第一个元素，所以p标签和第一个h3标签的背景变蓝了。]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css基础]]></title>
    <url>%2F2017%2F12%2Fcss%E5%9F%BA%E7%A1%80.html</url>
    <content type="text"><![CDATA[CSS的全称是什么?层叠样式表（英语：Cascading Style Sheets，简写CSS），一种用来为结构化文档（如HTML文档或XML应用）添加样式（字体、间距和颜色等）的计算机语言，由W3C定义和维护。 CSS有几种引入方式? link 和@import 有什么区别?CSS有几种引入方式四种，分别为行内样式，内嵌样式和外联样式以及@import link 和@import 有什么区别 link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。 link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。所以有时候浏览@import加载CSS的页面时开始会没有样式（就是闪烁）。 link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。 link支持使用Javascript控制DOM去改变样式；而@import不支持。 以下这几种文件路径分别用在什么地方，代表什么意思? css/a.css相对路径，当前目录下css文件夹内a.css文件 ./css/a.css相对路径，同级目录下css文件夹内a.css文件 b.css相对路径，与当前文档同级目录下b.css文件 ../imgs/a.png相对路径，上级文件夹下imgs文件夹内a.png文件 /Users/hunger/project/css/a.css绝对路径，根目录下对应路径的文件 /static/css/a.css绝对路径，根目录下对应路径的文件 http://cdn.jirengu.com/kejian1/8-1.png绝对路径，表示饥人谷该网站kejian1目录下的名为8-1.png的图片地址 列出5条以上html和 css 的书写规范 一次缩进2个空格，不要使用 tab 或者混合 tab 和空格的缩进。 HTML 元素名称，属性，属性值（除非 text/CDATA），CSS 选择器，属性，属性值应该使用小写。 结尾切勿加空格空格不仅多余，而且在比较代码时会更麻烦。 在 HTML 中通过指定编码方式，CSS 中不需要指定，因为默认是 UTF-8。 使用注释来解释代码：包含的模块，功能以及优点。]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[form表单]]></title>
    <url>%2F2017%2F12%2Fform%E8%A1%A8%E5%8D%95.html</url>
    <content type="text"><![CDATA[form表单有什么作用？有哪些常用的input 标签，分别有什么作用？表单在网页中主要负责数据采集功能。一个表单有三个基本组成部分： 表单标签：这里面包含了处理表单数据所用CGI程序的URL以及数据提交到服务器的方法。 表单域：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等。 表单按钮：包括提交按钮、复位按钮和一般按钮；用于将数据传送到服务器上的CGI脚本或者取消输入，还可以用表单按钮来控制其他定义了处理 常见的input标签: 标签 作用 text 单行文本框 password 密码框 checkbox 多选输入框 radio 单选按钮 file 上传文件 hidden 隐藏域 submit 数据提交按钮 button 普通按钮 post 和 get 方式的区别 GET提交：请求的数据会附在URL之后(就是把数据放置在HTTP协议头中)，以?分割URL和传输数据，多个参数用&amp;连接。如果数据是英文字母数字，原样发送，如果是空格，转换为+，如果是中文其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中%XX中的XX为该符号以16进制表示的ASCII。示例：点击提交,地址跳转为 POST提交：把提交的数据放置在是HTTP包的包体中。示例：点击提交后信息并没有显示在地址栏里面因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变。 传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制 而在实际开发中存在的限制主要有： GET: 特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2K+35。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。 POST: 由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。 name属性 作为可与服务器交互数据的HTML元素的服务器端的标示，比如input、select、textarea、和button等。我们可以在服务器端根据其Name通过Request.Params取得元素提交的值。 HTML元素Input type=’radio’分组，我们知道radio button控件在同一个分组类，check操作是mutex的，同一时间只能选中一个radio，这个分组就是根据相同的Name属性来实现的。 建立页面中的锚点，我们知道&lt;a href=&quot;URL&quot;&gt;link&lt;/a&gt;是获得一个页面超级链接，如果不用href属性，而改用Name，如：&lt;a name=&quot;PageBottom&quot;&gt;&lt;/a&gt;，我们就获得了一个页面锚点。 作为对象的Identity，如Applet、Object、Embed等元素。比如在Applet对象实例中，我们将使用其Name来引用该对象。 在IMG元素和MAP元素之间关联的时候，如果要定义IMG的热点区域，需要使用其属性usemap，使usemap=”#name”(被关联的MAP元素的Name)。 某些特定元素的属性，如attribute，meta和param。例如为Object定义参数或Meta中。 radio如何分组在同一个分组里，name属性要有相同的值。12&lt;input type="radio" name="gender" value="male"&gt;&lt;input type="radio" name="gender" value="female"&gt; placeholder 属性有什么作用?可以在文本输入框内显示默认的提示字符 type=hidden隐藏域有什么作用? 举例说明 隐藏数据一起发送给服务器。 作为LocalStorage的替代品。 当有多个submit按钮时，可以用于确认是哪个按钮提交的表单。 可以用于联系多个表单。 作为全局变量使用。 作为父窗口的隐藏域，对小窗口传参。 input type=’submit’ 和type=’button’ 有什么区别在一个页面上话一个按钮有四种方法：1234567&lt;!-- 这就是一个按钮。如果你不写javascript 的话，按下去什么也不会发生。 --&gt;&lt;input type="button"&gt;&lt;!-- 这样的按钮用户点击之后会自动提交 form，除非你写了javascript 阻止它。 --&gt;&lt;input type="submit" /&gt;&lt;!-- 这个按钮放在 form 中也会点击自动提交，比前两个的优点是按钮的内容不光可以有文字，还可以有图片等多媒体内容。（当然，前两个用图片背景也可以做到）。它的缺点是不同的浏览器得到的 value 值不同；可能还有其他的浏览器兼容问题 --&gt;&lt;button&gt;&lt;!-- 其他标签，例如 a, img, span, div，然后用图片把它伪装成一个按钮。 --&gt;]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端利用动态rem实现自适应布局（一）]]></title>
    <url>%2F2017%2F12%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%88%A9%E7%94%A8%E5%8A%A8%E6%80%81rem%E5%AE%9E%E7%8E%B0%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[什么是rem这个单位代表根元素的 font-size 大小（例如 &lt;html&gt; 元素的font-size）当用在根元素的font-size上面时 ，它代表了它的初始值(译者注:默认的初始值是html的默认的font-size大小,比如当未在根元素上面设置font-size大小的时候,此时的1rem==1em,当设置font-size=2rem的时候,就使得页面中1rem的大小相当于html的根字体默认大小的2倍,当然此时页面中字体的大小也是html的根字体默认大小的2倍)。 自适应的精髓就是让盒子的大小，间距等与视窗的大小相关。如何用rem做到这一点？我们可以通过js来获取视窗的宽度，然后给html一个font-size值，让两者关联起来 有这样一个需求。有四个div盒子，每个盒子的宽度是高度的两倍，盒子中间的间距是周围间距的两倍，效果如下。并且在不同屏幕宽度小都能呈现出相同的效果 123var pageWidth = window.innerWidth document.write(`&lt;style&gt;html&#123;font-size:$&#123;pageWidth/10&#125;px;&#125;&lt;/style&gt;`) &lt;/script&gt; 12345678&lt;body&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt;box1&lt;/div&gt; &lt;div class="child"&gt;box2&lt;/div&gt; &lt;div class="child"&gt;box3&lt;/div&gt; &lt;div class="child"&gt;box4&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 12345678910111213141516171819* &#123; margin: 0; padding: 0; box-sizing: border-box; &#125;body &#123; font-size: 16px; &#125;clear::after &#123; content: ''; display: block; clear: both; &#125;.child &#123; width: 4rem; height: 2rem; margin: 0.5rem 0.5rem; float: left; background: #8e8585; &#125; 这样有一个问题，我每次都要计算才能得到给多少rem值，这样很麻烦。我们可以通多scss里面的函数解决这个问题。123456789101112131415161718192021@function px2rem($px)&#123; @return $px/$designWidth *10+ rem&#125;$designWidth : 320;* &#123;margin: 0;padding: 0;box-sizing: border-box;&#125;body &#123;font-size: 16px;&#125;clear::after&#123; content: ''; display: block; clear: both;&#125;.child &#123; width: px2rem(128); height: px2rem(64); margin: px2rem(16) px2rem(16); float: left; background: #8e8585;&#125; 结尾：这只是一个简单的利用动态rem实现自适应的思路，更多的细节，需要持续关注。附上一篇大漠老师的文章使用Flexible实现手淘H5页面的终端适配]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML知识]]></title>
    <url>%2F2017%2F12%2FHTML%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[HTML、XML、XHTML 有什么区别HTML、XML和XHTML都是标准通用标记语言的一个子集。 HTML被设计用来显示数据，其焦点是数据的外观,是最早写网页的语言，但是由于时间早，规范不是很好，大小写混写且编码不规范； XML被设计用来传输和存储数据，其焦点是数据的内容。 XHTML是更严格更纯净的 HTML 版本，是作为一种 XML 应用被重新定义的 HTML，设计的目的是为了取代HTML以适应未来网络更多的需求。 它们都可以用来开发网页，但就目前来看，网页开发中HTML还是占绝对的主流，现在最新版本HTML5也备受推崇。可拓展标记语言XML广泛运用于各种应用程序中数据的存储（例如各种配置文件）和应用程序间的数据传输，可以说是一项必须掌握的技术。至于可扩展超文本标记语言XHTML，在2009年W3C已经宣布停止了对XHTML2的开发，转而大力支持HTML5。 怎样理解 HTML 语义化语义化的HTML就是写出的HTML代码，根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。语义化有助于： 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重。 在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看。 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 怎样理解内容与样式分离的原则 写 HTML 仅处理内容，只考虑 HTML 的结构和语义化，避免出现属性样式。 写 JS 的时候，尽量不使用 JS直接操作样式。 页面展现的所有样式，都由CSS来负责实现。 有哪些常见的meta标签12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- 关键字，搜所引擎 SEO --&gt;&lt;!-- 关键字，搜所引擎 SEO --&gt;&lt;meta http-equiv="keywords" content="关键字1,关键字2,..."&gt; &lt;!-- 页面描述 --&gt;&lt;meta http-equiv="description" content="网页描述"&gt; &lt;!-- content的取值为webkit,ie-comp,ie-stand之一，区分大小写，分别代表用webkit内核，IE兼容内核，IE标准内核。 --&gt;&lt;meta name="renderer" content="webkit|ie-comp|ie-stand"&gt;&lt;!-- 若页面需默认用极速核，增加标签： --&gt;&lt;meta name="renderer" content="webkit"&gt;&lt;!-- 若页面需默认用ie兼容内核，增加标签： --&gt;&lt;meta name="renderer" content="ie-comp"&gt;&lt;!-- 若页面需默认用ie标准内核，增加标签： --&gt;&lt;meta name="renderer" content="ie-stand"&gt;&lt;!-- 如果安装了GCF，则使用GCF来渲染页面，如果没有安装GCF，则使用最高版本的IE内核进行渲染。X-UA-Compatible：这是个是IE8的专用标记,用来指定IE8浏览器去模拟某个特定版本的IE浏览器的渲染方式(比如人见人烦的IE6)，以此来解决部分兼容问题。 --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" &gt;&lt;!-- 强制页面在当前窗口以独立页面显示。 --&gt;&lt;meta http-equiv="Window-target" content="_top"&gt;&lt;!-- 自动刷新，并指向新的页面 --&gt;&lt;meta http-equiv="Refresh" content="2；URL=http://"&gt;&lt;!-- 禁止浏览器缓存 --&gt;&lt;!-- 是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出用法： --&gt;&lt;meta http-equiv="pragram" content="no-cache"&gt; &lt;!-- 清除缓存（再访问这个网站要重新下载！） --&gt;&lt;meta http-equiv="cache-control" content="no-cache, must-revalidate"&gt; &lt;!-- 设定网页的到期时间 --&gt;&lt;meta http-equiv="expires" content="0"&gt; &lt;!-- 手机端 --&gt;&lt;meta name="format-detection" content="telphone=no, email=no"/&gt;&lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;&lt;meta name="apple-mobile-web-app-status-bar-style" content="black"/&gt;&lt;!-- 设置苹果工具栏颜色 --&gt;&lt;!-- 不让百度转码 --&gt;&lt;meta http-equiv="Cache-Control" content="no-siteapp" /&gt;&lt;!-- 不缓存 --&gt;&lt;meta http-equiv="cache-control" content="no-cache" /&gt;&lt;!-- 初始化设备 --&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimal-ui" /&gt;&lt;!-- 网站开启对iphone私有 web app 程序的支持 --&gt;&lt;meta content="yes" name="apple-mobile-web-app-capable" /&gt;&lt;!-- 改变顶部状态条的颜色 iphone私有的属性--&gt;&lt;meta content="black" name="apple-mobile-web-app-status-bar-style" /&gt; 文档声明的作用?严格模式和混杂模式指什么?&lt;!doctype html&gt;的作用文档声明的作用文档声明指出阅读程序应该用什么规则集来解释文档中的标记。在web文档的情况下，“阅读程序”通常是浏览器或者校验器这样的一个程序，“规则”则是w3c所发布的一个文档类型定义（dtd）中包含的规则。每个dtd都包括一系列标记、attributes和properties，它们用于标记web文档的内容；此外还包括一些规则，它们规定了哪些标记能出现在其他哪些标记中。每个web建议标准（比如html 4 frameset和xhtml 1.0 transitional）都有自己的dtd。假如文档中的标记不遵循doctype声明所指定的dtd，这个文档除了不能通过代码校验之外，还有可能无法在浏览器中正确显示。对于标记不一致的问题，浏览器相较于校验器来说更宽容。但是，不正确的doctype声明经常导致网页不正确显示，或者导致它们根本不能显示。 严格模式和混杂模式指什么严格模式：又称标准模式，是指浏览器按照 W3C 标准解析代码。 混杂模式：又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码。 如何区分：浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。 如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。（严格 DTD ——严格模式）包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。（DTD不存在或者格式不正确——混杂模式）HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。（ HTML5 没有严格和混杂之分）意义：严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，每个浏览器都有自己的解析模式。 &lt;!doctype html&gt;的作用声明文档的解析类型(document.compatMode)，避免浏览器的怪异模式 document.compatMode：BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。CSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面。 这个属性会被浏览器识别并使用，但是如果你的页面没有DOCTYPE的声明，那么compatMode默认就是BackCompat,这也就是绝望和黑暗的开始 – 浏览器按照自己的方式解析渲染页面，那么，在不同的浏览器就会显示不同的样式。如果你的页面添加了&lt;!DOCTYPE html&gt;那么，那么就等同于开启了标准模式，那么浏览器就得老老实实的按照W3C的标准解析渲染页面，这样一来，你的页面在所有的浏览器里显示的就都是一个样子了。这就是&lt;!DOCTYPE html&gt;的作用。 浏览器乱码的原因是什么？如何解决造成html网页乱码原因主要是html源代码内中文字内容与html编码不同造成。但无论是哪种情况造成乱码解决方法都是在网页开始时候设置网页编码 常见的浏览器有哪些，什么内核 浏览器 市场占有率 内核 Chrome 58.64% WebKit/Chromium引擎 Internet Explorer 18.95% Trident Firefox 11.79% Gecko Edge 5.61% Trident Safari 3.37% WebKit Opera 1.18% Presto]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
</search>
