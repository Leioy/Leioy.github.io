<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[书籍推荐]]></title>
    <url>%2F2017%2F12%2F%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90.html</url>
    <content type="text"><![CDATA[前端优质书籍推荐《DOM JavaScript编程艺术》—-JavaScript最好的入门书，没有之一，这本书是帮助你了解如何将DOM、CSS和JavaScript连接起来的一本书。《JavaScript高级程序设计》—-JavaScript必读的一本精典，读完之后对JavaScript的理解和实践会上升非常大的一个台阶。《编写高质量代码——Web前端开发修炼之道》《HTML5和CSS3权威指南》《响应式Web设计：HTML5和CSS3实战》《JavaScript设计模式》]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP]]></title>
    <url>%2F2017%2F12%2FHTTP.html</url>
    <content type="text"><![CDATA[DNS是什么DNS存储了域名和IP的对应关系baidu.com &gt;&gt;&gt; 111.13.101.208一个域名可以对应多个IP一个域名对应的IP是由域名所有者指定的DNS可能有缓存 OSI 七层模型指什么OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互联模型。该体系结构标准定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层），即ISO开放系统互连参考模型。在这一框架下进一步详细规定了每一层的功能，以实现开放系统环境中的互连性、互操作性和应用的可移植性关于OSI七层模型的形象解释从高层到底层分别为： 层级名称 英文名称 应用举例 描述 应用层 Application HTTP FTP TFTP SMTP SNMP DNS 网络服务与最终用户的一个接口 表示层 Presentation Layer JPEG、ASCll、DECOIC、加密格式 数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层） 会话层 Session Layer 对应主机进程，指本地主机与远程主机正在进行的会话 建立、管理、终止会话。（在五层模型里面已经合并到了应用层） 传输层 Transport TCP UDP 定义传输数据的协议端口号，以及流控和差错效验 网络层 Network ICMP IGMP IP（IPV4 IPV6） ARP RARP 进行逻辑地址寻址，实现不同网络之间的路径选择 数据链路层 Link 网卡，网桥，二层交换机等 建立逻辑连接、进行硬件地址寻址、差错效验等功能。（由底层网络定义协议） 物理层 Physical Layer 中继器，集线器，网线，HUB等 建立、维护、断开物理连接。（由底层网络定义协议） 将会话层和表示层、应用层合并为一层，称之为“五层模型”在五层模型的基础上将物理层和数据链路层合并为一层，称之为“四层模型” HTTP 的工作原理是什么？HTTP由请求和响应构成，是一个标准的客户端服务器模型（B/S）。HTTP协议永远都是客户端发起请求，服务器回送响应。一次HTTP操作称为一个事务，其工作整个过程如下： 地址解析用客户端浏览器从URL中分解出协议名、主机名、端口、对象路径等部分，需要域名系统DNS解析域名localhost.com,得主机的IP地址。 封装HTTP请求数据包把以上部分结合本机自己的信息，封装成一个HTTP请求数据包 封装成TCP包，建立TCP连接（TCP的三次握手）在HTTP工作开始之前，客户机（Web浏览器）首先要通过网络与服务器建立连接，HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接。 客户机发送请求命令建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可选内容。 服务器响应服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据 服务器关闭TCP连接（TCP的四次挥手）一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码Connection:keep-aliveTCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 附：HTTPS加密原理 URI 的格式是什么？常见的协议有哪些URI是采用一种特定语法标识一个资源的字符串，称之为“统一资源标识符”格式：协议//用户名:密码@授权机构:端口号/路径?查询字符串#哈希例如：ftp://mp3:mp3@ci43198-a.ashvill.nc.home.com:33/VanHalen-Jump.mp3所有其他字符及内容中需用到的定界符也应用%转义（空格%20 /%2F） 常见的协议： 协议 描述 data 链接中直接包含的Base64编码数据 file 本地磁盘的文件 ftp FTP服务器 http 使用超文本传输协议的国际互联网服务器 mailto 电子邮件地址 magnet 可以通过对等网络下载的资源 telnet 与基于Telnet的服务连接 HTTP 协议有几种和服务器交互的方法以HTTP 1.1标准，有如下几种方法： GET：获取资源GET方法用来请求访问已被URL识别的资源 POST：传输实体主体POST方法用来请求服务器传输信息实体的主体 PUT：传输文件PUT要求在请求报文的主体中包含文件内容，然后保存到请求URL指定的位置处于安全考虑，一般web网站不使用此方法，若配合web的安全验证机制，或者架构采用REST标准的网站，就可能开放使用此方法 HEAD：获得报文首部HEAD和GET方法一样，只不过不返回报文主体部分，用于确认URI的有效性及资源更新的日期时间等 DELETE：删除文件DELETE是与PUT相反的方法，是按请求URI删除指定的资源处于安全考虑，一般web网站不使用此方法，若配合web的安全验证机制，或者架构采用REST标准的网站，就可能开放使用此方法 OPTIONS：询问支持的方法用来查询针对请求URI指定的资源支持的方法 TRACE：追踪路径是让web服务器端将之前的请求通信还回给客户端的方法发送请求时，在Max-Frowards首部字段中填入数值，每经过一个服务器端就-1，当数值为0时，停止传输，最后收到服务器返回状态码200 OK的响应但是，这种方法基本很少使用，而且很容易引起XST（跨站追踪）攻击，就更不会用到了。 CONNECT：要求采用隧道协议连接代理该方法要求在于代理服务器通信时建立隧道，实现用隧道协议进行TCP通信，主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经过网络传输。 状态码200，301，304，403,404,500，503分别代表什么意思 200 OK请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码是表示正常状态。 301 Moved Permanently被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。新的永久性的URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。 304 Not Modified如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。该响应必须包含以下的头信息：Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。ETag 和/或 Content-Location，假如同样的请求本应返回200响应。Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。 403 Forbidden服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。 404 Not Found请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。 500 Internal Server Error服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。 503 Service Unavailable由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。 报文有哪几部分组成？ 请求头 首部 主体的的格式和作用 如图所示，为一个完整的请求报文。格式已经在上题中写明，下面列出作用。 HTTP请求头规定了请求的方法，地址，协议版本，本例中使用POST方法请求http://host_name/path地址，协议版本为HTTP1.1。 HTTP首部规定了一个请求的约束和规则，以键值对的形式呈现。本例中的头部键值对分别表达了以下意思： Host: host_name 访问的宿主服务器是host_name Content-Type: text/xml 定义文件接收类型为text/xml格式接收 Content-Length: 18 消息实体的传输长度，压缩后的message-body的长度为18字节 If-Modified-Since: Sat, 02 May 2015 16:17:00 GMT 浏览器最后修改页面缓存的时间，可以让服务器与自己的数据更改时间进行比较 If-None-Match: “03fb33c0bfcc” If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能 Pragma: Public 指定了缓存的规则，本例子中的参数Public意味着可以被任何缓存所缓存 Accept: text/html 浏览器端可以接受的媒体类型，本例中指定为html文档 Accept-Encoding: gzip 指定了代码传输的压缩方式，本例中指定了gzip压缩方式 请求主体的内容由传输者定义，传递了客户端到服务器的内容，其格式可以任意指定。本例中传递了两个键值对。 简述浏览器缓存是如何控制的当浏览器第一次访问服务器请求资源时，服务器会返回资源本体和两条缓存信息（缓存信息以http请求首部的形式定义），分别为Cache-Control和Etag。其中Cache-Control定义了何时缓存过期和缓存的各种存储细节，而Etag则是这个资源的一个特征标识符，只有当资源改变时这个标识符才会改变。当浏览器在此需要这个资源时，先通过检测这个资源的Cache-Control是否已经过期来判断是否需要向服务器发起请求再次索取这个资源，如果没有过期则直接使用缓存资源，如果过期了就连同资源的Etag一起向服务器发送请求索取资源。服务器接收到再次索取资源的请求，比对云端的Etag与请求的Etag是否相等，如果相等，则返回一个304，如果不等，则将新的资源发送给客户端。 下图各个参数是什么意思 用PUT方法请求Request URL地址，请求正常故状态码为200 OK，请求的远程地址（实际IP和端口）是Remote Address。请求TCP链接不要断开，消息实体的传输长度为12个字节，服务器回应的数据格式为json，时间为Date，服务器采用的软件为ngix，框架是Express。客户端请求的数据为任何格式，接受gzip，deflate，sdch编码压缩，只接受中文，对中文的喜好程度是0.8，传输的消息实体的长度为56个字节，传输主体类型为Content-Type，并且设置了cookie，传输的主机和来源站点是note.ruoyu.site，从note.ruoyu.site链接过来，有一些用户信息，传递信息的方式是Ajax。传递的消息主题有一些键值对，其中一个就是article: 若愚@饥人谷]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件]]></title>
    <url>%2F2017%2F12%2F%E4%BA%8B%E4%BB%B6.html</url>
    <content type="text"><![CDATA[DOM0 事件和DOM2级在事件监听使用方式上有什么区别？DOM0级事件监听就是把一个方法赋值给一个元素的事件处理程序属性。将这些属性的值设置为一个函数，就可以指定事件处理程序。一个事件只能绑定一次，并且新方法会覆盖老方法。例如btn.onclick=function(){} DOM2级事件监听定义了两个方法用于处理指定和删除事件处理程序的操作：addEventListener、removeEventListener。所有的DOM节点都包含这两个方法，并且它们都接受三个参数：事件类型、事件处理方法、布尔参数。例如addEventListener、removeEventListener。可以选择按照冒泡的顺序处理还是捕获的顺序处理。 attachEvent与addEventListener的区别？1.参数个数不相同，这个最直观，addEventListener有三个参数，attachEvent只有两个，attachEvent添加的事件处理程序只能发生在冒泡阶段，addEventListener第三个参数可以决定添加的事件处理程序是在捕获阶段还是冒泡阶段处理（我们一般为了浏览器兼容性都设置为冒泡阶段）2.第一个参数意义不同，addEventListener第一个参数是事件类型（比如click，load），而attachEvent第一个参数指明的是事件处理函数名称（onclick，onload）3.事件处理程序的作用域不相同，addEventListener的作用域是元素本身，this是指的触发元素，而attachEvent事件处理程序会在全局变量内运行，this是window4.为一个事件添加多个事件处理程序时，执行顺序不同，addEventListener添加会按照添加顺序执行，而attachEvent添加多个事件处理程序时顺序无规律(添加的方法少的时候大多是按添加顺序的反顺序执行的，但是添加的多了就无规律了) 解释IE事件冒泡和DOM2事件传播机制？IE事件冒泡是指事件信息DOM树中接受事件的最下层开始向上传递直到根节点。DOM2事件传递机制是指先进行事件捕获后进行事件冒泡。事件信息从DOM根节点开始逐层下传到事件发生的目标元素，在达到目标元素后逐层冒泡上传至根节点 如何阻止事件冒泡？ 如何阻止默认事件？DOM浏览器：在DOM2级事件监听的第二个参数即匿名函数内使用e.stopPropagation()IE浏览器：window.event.cancelBubble = true;//停止冒泡window.event.returnValue = false;//阻止事件的默认行为]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dom操作]]></title>
    <url>%2F2017%2F12%2Fdom%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[dom对象的innerText和innerHTML有什么区别？ innerText不包含文档结构，只会包含对象的文本内容 innerHTML包含文档结构，标签属性等信息 elem.children和elem.childNodes的区别？ elem.childNodes包含HTML节点，文本节点，属性节点 elem.children只包含子HTML节点 查询元素有几种常见的方法？ES5的元素选择方法是什么?DOM0查询元素方法： document.getElementById(‘id’) document.getElementsByTagName(‘tagName’) document.getElementsByClassName(‘className’) DOM3(ES5)查询元素方法 document.querySelector(‘cssQuerySelector’) 如何创建一个元素？如何给元素设置属性？如何删除属性创建元素： createElement方法用来生成HTML元素节点。 createTextNode方法用来生成文本节点，参数为所要生成的文本节点的内容。 createDocumentFragment方法生成一个DocumentFragment对象。 setAttribute()方法用于设置元素属性；removeAttribute()用于删除元素属性 如何给页面元素添加子元素？如何删除页面元素下的子元素?创建元素createElement，用来生成HTML元素节点。1var newDiv = document.createElement("div") createTextNode，用来生成文本节点，参数为所要生成的文本节点的内容。12var newDiv = document.createElement("div")var newContent = document.createTextNode("Hello") createDocumentFragment,用来生成一个DocumentFragment对象。DocumentFragment对象是一个存在于内存的DOM片段，但是不属于当前文档，常常用来生成较复杂的DOM结构，然后插入当前文档。这样做的好处在于，因为DocumentFragment不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的DOM有更好的性能表现。 修改元素appendChild,在元素末尾添加元素insertBefore，在某个元素之前插入元素replaceChild，replaceChild()接受两个参数：要插入的元素和要替换的元素1newDiv.replaceChild(newElement, oldElement) 删除元素1parentNode.removeChild(childNode) clone元素cloneNode()方法用于克隆元素，方法有一个布尔值参数，传入true的时候会深复制，也就是会复制元素及其子元素（IE还会复制其事件），false的时候只复制元素本身 属性操作getAttribute()用于获取元素的attribute值createAttribute()方法生成一个新的属性对象节点，并返回它。setAttribute()方法用于设置元素属性removeAttribute()用于删除元素属性 上面的方法做的事情也可以通过类操作数组属性element.attributes来实现 location属性location属性返回一个只读对象，提供了当前文档的URL信息123456789101112131415161718192021222324// 假定当前网址为http://www.example.com:4097/path/a.html?x=111#part1document.location.href // "http://www.example.com:4097/path/a.html?x=111#part1"document.location.protocol // "http:"document.location.host // "www.example.com:4097"document.location.hostname // "www.example.com"document.location.port // "4097"document.location.pathname // "/path/a.html"document.location.search // "?x=111"document.location.hash // "#part1"document.location.origin //http://www.example.com:4097// 跳转到另一个网址document.location.assign('http://www.google.com')// 优先从服务器重新加载document.location.reload(true)// 优先从本地缓存重新加载（默认值）document.location.reload(false)// 跳转到另一个网址，但当前文档不保留在history对象中，即无法用后退按钮，回到当前文档document.location.replace('http://www.baidu.com')//虽然location属性返回的对象是只读的，但是可以将URL赋值给这个属性，网页就会自动跳转到指定网址。document.location = 'http://www.example.com'&lt;===&gt; document.location.href = 'http://www.example.com' dom常用API总结]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引用类型对象拷贝]]></title>
    <url>%2F2017%2F12%2F%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D.html</url>
    <content type="text"><![CDATA[引用类型有哪些？非引用类型有哪些引用类型包括：对象，数组，函数，正则。指的是那些保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针执行内存中的另一个位置，由该位置保存对象。基本类型值包括：数值，布尔值，null和undefined。指的是保存在栈内存中的简单数据段。 如下代码输出什么？为什么12345var obj1 = &#123;a:1, b:2&#125;;var obj2 = &#123;a:1, b:2&#125;;console.log(obj1 == obj2); //falseconsole.log(obj1 = obj2); //&#123;a:1,b:2&#125;(事实上是obj2的内容，实际传的值为obj2的指针)console.log(obj1 == obj2);//true 两者变量内存储的指针相等 如下代码输出什么？为什么12345678910111213141516171819var a = 1var b = 2var c = &#123; name: '饥人谷', age: 2 &#125;var d = [a, b, c]var aa = avar bb = bvar cc = cvar dd = da = 11b = 22c.name = 'hello'd[2]['age'] = 3console.log(aa) //1，传值赋值console.log(bb) //2，传值赋值console.log(cc) //&#123;name:"hello",age:3&#125;,传引用赋值console.log(dd) //[1, 2, &#123;name:"hello",age:3&#125;],前两个数组元素传值，第三个传引用 以下代码输出？为什么？123456789101112131415var a = 1var c = &#123; name: 'jirengu', age: 2 &#125;function f1(n)&#123; ++n&#125;function f2(obj)&#123; ++obj.age&#125;f1(a) f2(c) f1(c.age) console.log(a) //输出1，f1中相当于是声明了一个n=a，是把a的值赋给了n，++n变化的n的值，a不会发生变化。console.log(c) //输出&#123;name: "jirengu", age: 3&#125;，f2()中相当于obj=c。把c指向的地址赋值给了obj，所以++obj.age后，指向的地址内的值发生了变化，再打印c的时候打印的是指向的地址内的值，所以age变成3 过滤如下数组，只保留正数，直接在原数组上操作1234567891011var arr = [3,1,0,-1,-3,2,-5]function filter(array)&#123; for(var i = 0;i&lt;array.length;i++)&#123; if(array[i] &lt;= 0)&#123; array.splice(i,1) i-- &#125; &#125; return array&#125;filter(arr) //[3,1,2] 过滤如下数组，只保留正数，原数组不变，生成新数组1234567891011var arr = [3,1,0,-1,-3,2,-5]function filter(arr)&#123; var newArr = [] for(var i = 0;i &lt; arr.length;i++)&#123; if(arr[i] &gt; 0)&#123; newArr.push(arr[i]) &#125; &#125; return newArr&#125;filter(arr) 写一个深拷贝函数，用两种方式实现1234567891011121314151617181920212223var obj=&#123; a:1, b:2, c:&#123; d:1, e:2 &#125;&#125;function deepCopy1(obj)&#123; var result = &#123;&#125; for(var key in obj)&#123; result[key] = (typeof obj[key] === 'object')?deepCopy1(obj[key]):obj[key] &#125; return result&#125;deepCopy1(obj)function deepCopy2(obj)&#123; var result = &#123;&#125; result = JSON.parse(JSON.stringify(obj)) return result&#125;deepCopy2(obj)]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数声明和函数表达式]]></title>
    <url>%2F2017%2F12%2F%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
    <content type="text"><![CDATA[函数声明和函数表达式有什么区别函数声明和函数表达式都能够定义一个函数。函数声明是指使用function关键字定义一个函数，不必放在调用的前面。函数表达式则是将函数的指针赋值给声明变量，本质上是一个表达式，使用时必须放在调用的前面。 什么是变量的声明前置？什么是函数的声明前置变量声明前置就是在一个作用域中，所有的变量都被放在作用域的顶部声明，举例：123456789console.log(a);var a=1;console(a);相当于var a;console.log(a);//undefineda=1;console.log(a);//1 函数声明前置把函数提升到作用域的顶部声明（函数表达式不可以），举例：12345678sayHello(); //hellosayHi(); //报错function sayHello()&#123; console.log("hello");&#125;var sayHi=function()&#123; console.log("hi");&#125; arguments 是什么arguments是一个类数组对象，类似数组的方式，可以通过下标的方式去获取值，但它本身不是数组，没有数组的一些特性，所以叫类数组对象。在函数内部，可以使用arguments对象获取到该函数的所有传入参数 函数的”重载”怎样实现重载是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。JS并不像其他强类型语言一样可以声明重载函数，若在原先声明的函数后再声明一个不同参数数量的函数(JS是弱语言，声明的函数不需要指明参数类型)，解析器会用后面声明的函数覆盖前面声明的函数。 1.在函数体内针对不同的参数调用执行相应的逻辑1234567function printInfo(name, age, sex)&#123; if(name)&#123; console.log(name)&#125; &#125; if(age)&#123; console.log(age) &#125; if(sex)&#123; console.log(sex) &#125; &#125; printInfo('xxx', 26) printInfo('xxx', 26, 'male') 2.使用arguments属性12345function printInfo(name, age, sex)&#123; console.log(arguments) &#125; printInfo('xxx', 26) printeInfo('xxx', 26, 'male') 立即执行函数表达式是什么？有什么作用立即执行函数的作用是隔离作用域，使被执行的函数内部的变量不会污染到外部，即外部不能访问函数内部的变量。参考]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型运算符流程控制语句]]></title>
    <url>%2F2017%2F12%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html</url>
    <content type="text"><![CDATA[JavaScript 定义了几种数据类型? 哪些是原始类型?哪些是复杂类型?原始类型和复杂类型的区别是什么?数据类型： 数值（number）:整数和小数（比如1和3.14） 字符串（string）：字符组成的文本（比如”Hello World”） 布尔值（boolean）：true（真）和false（假）两个特定值 undefined：表示“未定义”或不存在，即此处目前没有任何值 null：表示空缺，即此处应该有一个值，但目前为空 对象（object）：各种值组成的集合 Symbol: ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种。Symbol 是一个原始类型的值，不是对象。阮一峰es6入门 数值、字符串、布尔值称,Symbol(es6新增)为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了 将对象称为复杂类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。 至于undefined和null，一般将它们看成两个特殊值。 typeof和instanceof的作用和区别?typeof运算符返回一个对象的类型，可能返回三种基本类型以及function，undefined，以及object，是一个一元运算符。instanceof是一个二元运算符，用于判断某个变量是否是某个对象的实例。左边连接需要判断的变量，右边连接预期的类型，如果相符则返回true，不符则返回false。instanceof可以判断数组和对象。 如何判断一个变量是否是数字、字符串、布尔、函数JavaScript有三种方法，可以确定一个值到底是什么类型。 typeof运算符 instanceof运算符 Object.prototype.toString方法代码 toString()和valueOf()valueOf()：返回最适合该对象类型的原始值；toString(): 将该对象的原始值以字符串形式返回。 这两个方法一般是交由JS去隐式调用，以满足不同的运算情况。在数值运算里，会优先调用valueOf()，如a + b；在字符串运算里，会优先调用toString()，如alert(c)。JavaScript的toString()和valueOf()区别到底是什么 NaN是什么? 有什么特别之处?NaN，是Not a Number的缩写，在IEEE浮点数算术标准（IEEE 754）中定义，表示一些特殊数值（无穷与非数值（NaN）），为许多CPU与浮点运算器所采用。特别之处在于NaN和任何值都不相等，包括自己 如何把非数值转化为数值?Number: 如果是 Boolean 值，true 和 false 将分别被转换为 1 和0 如果是数字值，只是简单的传入和返回 如来是null 值，返回 0 如果是 undefined，返回NaN 如果是对象，则调用对象的 valueOf() 方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString() 方法，然后再次依照前面的规则转换返回的字符串值。 如果是字符串，遵循下列规则：1.如果字符串中只包含数字，则将其转换为十进制数值，即”1”会变 成1 ， “123”会变成123，而”011”会变成11（注意，前面的0被忽略了）2.如果字符串中包含有效的浮点格式， 如”1.1”，则将其转换为对应的浮点数值（同样，也会忽略前面的零）；3.如果字符串中包含有效的十六进制格式，例如”0xf”，则将其转换为相同大小的十进制整数值；4.如果字符串是空的（不包含任何字符） ，则将其转换为0；5.如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。 parseInt： 忽略字符串前面的空白字符，找到第一个非空白字符 如果第一个字符不是-或者数字返回NaN。如果是继续解析，直到非数值模式为止 0开头会当做八进制，0x开头会当做十六进制，但是可以指定第二个参数指定基数 parseFloat： parseFloat () 是从第一个字符（位置0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。举例来说，”22.34.5”将会被转换为22.34 。 除了第一个小数点有效之外， parseFloat () 与 parselnt() 的第二个区别在于它始终都会忽略前导的零。parseFloat() 可以识别前面讨论过的所有浮点数值格式，也包括十迸制整数格式，但十六进制格式的字符串则始终会被转换成0。由于 parseFloat() 只解析十进制值，因此它没有用第二个参数指定基数的用法。 ==与===有什么区别“==”包含了一个自动的隐式类型转换，规则如下： 如果一个是null，一个是undefined，那么相等 如果一个是数字，一个是字符串，先将字符串转为数字，然后比较 如果一个值是true/false则将其转为1/0比较 如果一个值是对象，一个是数字或字符串，则尝试使用valueOf和toString转换后比较 “===”则为严格相等，即类型与值必须全部相等,应尽量避免使用“==”。 break与continue有什么区别break：跳出循环，在一个循坏体内，一旦碰到break那么立即跳出循坏，后面所有的循坏都将不再执行。123456for(var i=1;i&lt;10;i++)&#123; if(i%4 == 0)&#123; break; &#125; console.log(i);打印的结果是（1,2,3） &#125; continue：跳出本次循环后，执行下次循坏123456for(var i=1;i&lt;10;i++)&#123; if(i%4 == 0)&#123; continue; &#125; console.log(i);打印的结果是（1,2,3,5,6,7,9） &#125; void 0 和 undefined在使用场景上有什么区别对于undefined,它的在全局作用域中，不会被重写，但在局部作用域中可以被重写。对于void可以给任何给定的表达式求值，并返回 undefined,并且 void 不可被重写，因此void 0是在局部作用域中替代undefined的最佳选择]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS相关概念]]></title>
    <url>%2F2017%2F12%2FJS%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5.html</url>
    <content type="text"><![CDATA[CSS和JS在网页中的放置顺序是怎样的？为了防止白屏与FOUC，CSS应放置于head标签内。为防止JS阻塞加载，JS应放置于body标签末尾。 简述网页的渲染机制 构建DOM树(DOM tree)：从上到下解析HTML文档生成DOM节点树（DOM tree），也叫内容树（content tree） 构建CSSOM(CSS Object Model)树：加载解析样式生成CSSOM树 执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件） 构建渲染树(render tree)：根据DOM树和CSSOM树,生成渲染树(render tree) 布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置 绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模块完成 相关文章 白屏和FOUC白屏浏览器的渲染需要先构建 DOM 和 CSSOM 树，假如 CSS 获取时间过长，就会导致 CSSOM 生成过久，浏览器只能等待，这时候就会出现长时间白屏，直到 DOM 和 CSSOM 构建完成。通常打开页面都会短暂白屏，因为 DOM 和 CSSOM 构建需要时间。 导致白屏的原因： 如果把样式放在底部,对于IE浏览器,由于DOM树过大，浏览器解析HTML文件时间过长但却没有解析CSS文件，在某些场景下(新窗口打开,刷新等)页面会出现白屏,而不是内容逐步展现 如果使用 @import 标签,即使 CSS 放入 link, 并且放在头部,也可能出现白屏 脚本会阻塞后面内容的呈现及其后组件的下载。对于图片和CSS, 在加载时会并发加载(如一个域名下同时加载两个文件). 但在加载 JavaScript 时,会禁用并发,并且阻止其他内容的下载. 所以把 JavaScript 放入页面顶部也会导致 白屏 现象 FOUC（Flash of Unstyled Content 无样式内容闪烁） 如果把样式放在底部,对于IE浏览器,在某些场景下(点击链接,输入URL,使用书签进入等),会出现 FOUC 现象(逐步加载无样式的内容,等CSS加载后页面突然展现样式).对于 Firefox 会一直表现出 FOUC Firefox浏览器经常出现FOUC现象与其渲染方式有关，Firefox在生成DOM后，将无样式内容展现，等到 CSSOM 生成了，再重绘渲染，这样就会看到一部分没样式的内容，然后再看到有样式的。这种分块分步的渲染 async和defer的作用是什么？有什么区别两者都是使脚本异步加载，没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。 async：加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 defer：加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 区别：defer:脚本延迟到文档解析和显示后执行，有顺序async:不保证顺序]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css综合]]></title>
    <url>%2F2017%2F12%2Fcss%E7%BB%BC%E5%90%88.html</url>
    <content type="text"><![CDATA[说一说你平时写代码遵守的编码规范 良好的命名规范ID和class的命名尽可能短，并符合语义。多个单词的拼接用 ‘-‘ 符号链接，尽量使用小写字母 代码缩写css代码缩写可以提高写代码的速度，精简代码质量。 利用CSS继承如果页面中父元素的多个子元素使用相同的样式，那最好把他们相同的样式定 义在其父元素上，让它们继承这些CSS样式。这样可以很好的维护代码，并且还可以减少代码量。 使用多重选择器可以合并多个CSS选择器为一个，如果他们有共同的样式的话。这样做不但代 码简洁且可节省时间和空间 适当的代码注释代码注释可以让别人更容易读懂代码，且合理的组织代码注释，可使得结构更加清晰。 选择更优的样式属性值CSS中有些属性采用不同的属性值，虽然达到的效果差不多，当性能上却存在着差异，如：区别在于border:0把border设为0px，虽然在页面上看不见，但按border默认值理解，浏览器依然对border-width/border-color进行了渲染，即已经占用了内存值。而border:none把border设为“none”即没有，浏览器解析“none”时将不作出渲染动作，即不会消耗内存值。所以建议使用border:none;同样的，display:none隐藏对象浏览器不作渲染，不占用内存。而visibility:hidden则会。 避免使用css hack 垂直居中有几种实现方式，给出代码范例绝对定位实现居中padding值实现居中添加伪元素实现居中display:table-celltable标签实现居中flex实现居中]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容]]></title>
    <url>%2F2017%2F12%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9.html</url>
    <content type="text"><![CDATA[什么是 CSS hackHack是针对不同的浏览器去写不同的CSS样式，从而让各浏览器能达到一致的渲染效果，那么针对不同的浏览器写不同的CSS CODE的过程，就叫CSS HACK，同时也叫写CSS Hack。 谈一谈浏览器兼容的思路 要不要做：产品的角度：（产品的受众、受众的浏览器比例、效果优先还是基本功能优先）成本的角度： (有无必要做某件事) 做到什么程度：让哪些浏览器支持哪些效果 如何做根据兼容需求选择技术框架/库(jquery)根据兼容需求选择兼容工具(html5shiv.js、respond.js、css reset、normalize.css、Modernizr) 列举5种以上浏览器兼容的写法 属性前缀法(即类内部Hack)：例如 IE6能识别下划线”_”和星号” “，IE7能识别星号” “，但不能识别下划线””，IE6~IE10都认识”\9”，但firefox前述三个都不能认识 123456.box &#123; color: red; _color: blue;/*IE6*/ *color: black;/*IE6,7*/ color: yellow;/*IE6-10*/&#125; 选择器前缀法(即选择器Hack)：比如IE6能识别*html .class{}，IE7能识别+html .class{} 条件注释 1&lt;!--[if IE 7]&gt;&lt;link rel="stylesheet" href="ie7.css" type="text/css"/&gt;&lt;![endif]--&gt; IE条件注释法结合选择器整体优化 利用normalize.css,统一所有浏览器样式 以下工具/名词是做什么的 条件注释条件注释是于HTML源码中被 IE 有条件解释的语句。条件注释可被用来向 IE提供及隐藏代码。 IE Hack针对IE浏览器编写不同的CSS的让IE能够在不同的正常渲染的过程 js 能力检测检测浏览器的能力检测目标不是检测特定的浏览器，而是检测浏览器的能力。这样，只需要检测浏览器是否支持特定的能力，就可以给出特定的解决方案。这一部分检测是解决浏览器兼容问题的主要检测。 html5shiv.jshtml5shiv.js是一个js库，用于解决IE9以下版本浏览器对HTML5新增标签不识别，并导致CSS不起作用的问题。 respond.jsRespond.js 是一个快速、轻量的 polyfill，用于为 IE6-8 以及其它不支持 CSS3 Media Queries 的浏览器提供媒体查询的 min-width 和 max-width 特性，实现响应式网页设计（Responsive Web Design）。 css reset重置浏览器的默认样式，更准确说就是通过重新定义标签样式，“覆盖”浏览器的CSS默认属性。 normalize.css先定义好一些CSS样式的同时保护有用的原生CSS样式，来让所有浏览器都按照同样的规则解释CSS。 ModernizrModernizr 是一个用来检测浏览器功能支持情况的 JavaScript 库。通过这个库我们可以检测不同的浏览器对于HTML5特性的支持情况。并以类标识的方式添加到标签中。 postCSSPostCSS是一个使用JavaScript插件来转换CSS的工具。能够达到兼容各种不同浏览器的效果，同时拥有很多插件。 一般在哪个网站查询属性兼容性？caniuse 查询css兼容性browserhacks查询Hack 的写法浏览器市场份额]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浮动定位BFC边距合并]]></title>
    <url>%2F2017%2F12%2F%E6%B5%AE%E5%8A%A8%E5%AE%9A%E4%BD%8DBFC%E8%BE%B9%E8%B7%9D%E5%90%88%E5%B9%B6.html</url>
    <content type="text"><![CDATA[浮动元素有什么特征？对父容器、其他浮动元素、普通元素、文字分别有什么影响?特征：浮动元素会脱离正常的文档流，按照其外边距指定的位置相对于它的上一个块级元素（或父元素）显示浮动元素后面的块级元素的内容会向此浮动元素的外边距靠齐，但是边框和背景却忽略浮动元素而向上一个任意非浮动元素靠齐浮动元素后面的内联元素会向此浮动元素的外边距靠齐 float造成的影响：对其父元素的影响对于其父元素来说，元素浮动之后，它脱离当前正常的文档流，所以它也无法撑开其父元素，造成父元素的塌陷 对其兄弟元素（非浮动）的影响如果兄弟元素为块级元素，该元素会忽视浮动元素的而占据它的位置，并且元素会处在浮动元素的下层（并且无法通过z-index属性改变他们的层叠位置），但它的内部文字和其他行内元素都会环绕浮动元素。如果如果兄弟元素为内联元素，则元素会环绕浮动元素排列。 对其兄弟元素（浮动）的影响同一个方向的浮动元素：当一个浮动元素在浮动过程中碰到同一个方向的浮动元素时，它会紧跟在它们后面反方向的浮动元素：互不影响，位于同一条水平线上，当空间不够时会被挤下 清除浮动指什么？如何清除浮动？浮动会导致：（1）背景不能显示 （2）边框不能撑开 （3）margin 设置值不能正确显示清除浮动就是消除这些不良影响清除浮动可以通过使包含块的父元素变成BFC；添加伪元素，在伪元素设置clear:both来实现 有几种定位方式，分别是如何实现定位的，参考点是什么，使用场景是什么？ inherit，从父元素继承position属性的值，一般不用 static默认值,没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明 relative，生成相对定位的元素，相对于元素本身正常位置进行定位。属性值：left, top,right ,bottom，应用于对其自身进行细微调整 absolute，生成绝对定位的元素，相对于static定位以外的第一个祖先元素（offset parent）进行定位 fixed，生成绝对定位的元素，相对于浏览器窗口进行定位。属性值：left, top,right ,bottom z-index 有什么作用? 如何使用?z-index规定了元素在Z轴（距离用户远近）上的顺序，值越大(需要同属于同一个层叠上下文关系)则越靠近用户，表现就是元素在最上面。关于z-index详细说明 position:relative和负margin都可以使元素位置发生偏移?二者有什么区别position：relative可以使元素发生偏移，但是在文档流中，它仍然占据着原来的位置，所以其他同级元素的位置不会发生变化。负margin：通过负margin进行偏移的元素，它会放弃偏移前占据的空间，所以其他同级元素的位置发生了变化。 BFC 是什么？如何生成 BFC？BFC 有什么作用？举例说明BFC：块级格式化上下文，它是指一个独立的块级渲染区域，只有Block-level BOX参与，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。 CSS2.1中规定满足下列CSS声明之一的元素便会生成BFC。 根元素 float的值不为none overflow的值不为visible display的值为inline-block、table-cell、table-caption position的值为absolute或fixed 作用： 不和浮动元素重叠 如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个覆盖的现象，很多自适应的两栏布局就是这么做的。 清除元素内部浮动 只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了 嵌套元素Margin边距折叠问题的解决 按照BFC的定义，只有同属于一个BFC时，两个元素才有可能发生垂直Margin的重叠，这个包括相邻元素，嵌套元素，只要他们之间没有阻挡(例如没有边框，非空内容，padding等)就会发生margin重叠。 因此要解决margin重叠问题，只要让它们不在同一个BFC就行了，只要把父元素设为BFC就可以了。这样子元素的margin就不会和父元素的margin发生重叠了 在什么场景下会出现外边距合并？如何合并？如何不让相邻元素外边距合并？给个父子外边距合并的范例场景： 同一个BFC，且同处于普通流中的垂直相邻元素外边距合并。 父子元素的外边距合并。 空元素的外边距合并。 合并规则： 两个margin都是正值的时候，取两者的最大值； 当 margin 都是负值的时候，取的是其中绝对值较大的，然后，从0位置，负向位移； 当有正有负的时候，先取出负 margin 中绝对值中最大的，然后，和正 margin 值中最大的 margin 相加。 所有毗邻的margin要一起参与运算，不能分步进行。 不让相邻元素外边距合并的方法： 被非空内容、padding、border 或 clear 分隔开。 不在一个普通流中或一个BFC中。 margin在垂直方向上不毗邻。 123&lt;div&gt; &lt;p style="margin-top:30px"&gt;这是一段文字&lt;/p&gt;&lt;/div&gt; 相关文章]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css常见样式2]]></title>
    <url>%2F2017%2F12%2Fcss%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F2.html</url>
    <content type="text"><![CDATA[text-align: center的作用是什么，作用在什么元素上？能让什么元素水平居中text-align: center;的作用是令元素水平居中，IE6/7及IE8混杂模式中，text-align:center可以使块级元素也居中对齐。其他浏览器中，text-align:center仅作用于行内内容上。 IE 盒模型和W3C盒模型有什么区别?IE盒模型的宽高：包含了border,padding,content的值。W3C盒模型的宽高：以content的宽度高度作为width和height *{ box-sizing: border-box;}的作用是什么？设置为IE盒模型，IE盒模型的宽高包含了border,padding,content的值。使用该属性，设置盒模型的宽高时，不用去考虑内部的计算，因为设置border，padding也不会增加该盒模型的宽高。 line-height: 2和line-height: 200%有什么区别?line-height: 2：设置行高为元素本身字体大小的两倍，无论字体大小，后代都会继承两倍行高这个关系line-height: 200%：设置行高为其父元素字体大小的两倍，后代只会继承固定的行高，不会继承两倍的行高。 inline-block有什么特性？如何去除缝隙？高度不一样的inline-block元素如何顶端对齐?具有内联和块级元素的特性：不会占据一整行；可以设置宽高，margin,padding 如何去除缝隙：标签不换行；设置父元素字体大小为0，然后单独设置字体大小如何顶端对齐：vertical-align: top; CSS sprite 是什么?CSSSprites在国内很多人叫css精灵，是一种网页图片应用处理方式。它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去,再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位。 其优点在于： 减少网页的http请求，提高性能，这也是CSS Sprites最大的优点，也是其被广泛传播和应用的主要原因； 减少图片的字节：多张图片合并成1张图片的字节小于多张图片的字节总和； 减少了命名困扰：只需对一张集合的图片命名，不需要对每一个小元素进行命名提高制作效率； 更换风格方便：只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变，维护起来更加方便。 其缺点在于： 图片合成比较麻烦； 背景设置时，需要得到每一个背景单元的精确位置； 维护合成图片时，最好只是往下加图片，而不要更改已有图片 让一个元素”看不见”有几种方式？有什么区别?123456#E &#123; opacity: 0;/* 变透明，仍占据位置*/ visibility: hidden;/*消失 占位置*/ display: none;/*消失 不占位置*/ background-color: rgba(0, 0, 0, 0);/*背景透明*/&#125;]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css常见样式]]></title>
    <url>%2F2017%2F12%2Fcss%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F.html</url>
    <content type="text"><![CDATA[块级元素和行内元素分别有哪些?有哪些区别？块级元素: div , p , form, ul, li , ol, dl, form, address, fieldset, hr, menu, table行内元素：span, strong, em, br, img , input, label, select, textarea, cite 区别： 块级元素会独占一行，其宽度自动填满其父元素宽度 行内元素不会独占一行，相邻的行内元素会排列在同一行里，直到一行排不下，才会换行，其宽度随元素的内容而变化 块级元素可以设置 width, height属性，行内元素设置width, height无效 块级元素可以设置margin 和 padding。行内元素可以设置margin和padding但是水平方向有效，竖直方向无效 什么是 CSS 继承? 哪些属性能继承，哪些不能？应用样式的元素的后代会继承样式的某些属性，比如颜色和字号。这种特点称作CSS继承。不可继承的：display、margin、border、padding、background、height、min-height、max- height、width、min-width、max-width、overflow、position、left、right、top、 bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、 page-bread-before和unicode-bidi。所有元素可继承：visibility和cursor。内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、 font-family、font-size、font-style、font-variant、font-weight、text- decoration、text-transform、direction。块级元素可继承：text-indent和text-align。列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。表格元素可继承：border-collapse。 如何让块级元素水平居中？如何让行内元素水平居中?块级元素水平居中一般使用margin: 0 auto;实现。行内元素水平居中一般使用text-align: center;实现。更多居中方法参考：css水平居中，垂直居中 单行文本溢出加 …如何实现?12345#E&#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; 多行文本溢出加…参考：如何实现单行文本/多行文本溢出的省略 px, em, rem 有什么区别?px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。(引自CSS2.0手册)em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(引自CSS2.0手册)rem是CSS3新增的一个相对单位（rootem，根em），区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。 解释下面代码的作用?为什么要加引号? 字体里\5b8b\4f53代表什么?123body&#123; font: 12px/1.5 tahoma,arial,'Hiragino Sans GB','\5b8b\4f53',sans-serif;&#125; 作用：定义body标签内的所有字体大小为12px，1.5倍行距，依次尝试tahoma,arial,’Hiragino Sans GB’,’\5b8b\4f53’,sans-serif 这几种字体，取较前的设定为所用字体。为什么要加引号：因为字体名称内部有空格，不加引号易引起歧义。\5b8b\4f53：‘宋体’两个字的Unicode 编码，在此可以代替‘宋体’两个字。]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css选择器]]></title>
    <url>%2F2017%2F12%2Fcss%E9%80%89%E6%8B%A9%E5%99%A8.html</url>
    <content type="text"><![CDATA[class 和 id 的使用场景?Html中的“类”（class）可以赋予给多个不同标签，而id每篇html文档只可以存在一次，因此class多用于某种统一的样式，而id多用于“仅此一种”的样式。实践上，对于样式而言，我们常常采用class而不是id。 CSS选择器常见的有几种? 基础选择器 1.通配符选择器 * { color:red } 2.id选择器 3.类选择器 4.标签选择器 组合选择器 1.多元素选择器：以,分隔，表示同时匹配多个选择器对应的元素 2.后代选择器：以空格分隔 属性选择器 1.E[attr]：筛选出所有具有属性名为attr的属性的元素 2.E[attr=value]：筛选出所有属性attr的值为vlaue的元素 伪类选择器 1.E:link：未被访问时的样式 2.E:visited：已经被访问后的样式 3.E:hover：鼠标悬停在a链接之上的样式 4.E:active：鼠标按下但未释放时的样式 5.E:first-child：父元素的各类标签中第一个子元素且必须符合指定类型（为E） 6.E:nth-child：匹配其父元素的第n个子元素 伪元素选择器 1.E:before：在E元素之前插入的内容 2.E:after：在E元素之后插入的内容 选择器的优先级是怎样的?对于复杂场景如何计算优先级？!important &gt; 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性 优先级计算方法：先数 id选择器数量，如果id选择器数量多的选择器权重高,如果id选择器数量相同，再数类选择器数量，最后数标签。 a:link, a:hover, a:active, a:visited 的顺序是怎样的？ 为什么？a:link：选择未被访问的链接，并设置其样式a:hover：选择鼠标指针浮动在其上的元素，并设置其样式a:active：选择活动链接，并设置其样式a:visited：选择已访问的链接，并设置其样式 在W3C规范中，也规定了链接的声明顺序：在 CSS 定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。 所以正确的顺序为：a:link、a:visited、a:hover、a:active 列出你知道的选择器E:first-child 匹配元素E的第一个子元素E:link 匹配所有未被点击的链接E:visited 匹配所有已被点击的链接E:active 匹配鼠标已经其上按下、还没有释放的E元素E:hover 匹配鼠标悬停其上的E元素E:enabled 匹配表单中可用的元素E:disabled 匹配表单中禁用的元素E:checked 匹配表单中被选中的radio或checkbox元素E::selection 匹配用户当前选中的元素E:nth-child(n) 匹配其父元素的第n个子元素，第一个编号为1E:nth-last-child(n) 匹配其父元素的倒数第n个子元素，第一个编号为1E:nth-of-type(n) 与:nth-child()作用类似，但是仅匹配使用同种标签的元素E:nth-last-of-type(n) 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素E:last-child 匹配父元素的最后一个子元素，等同于:nth-last-child(1)E:first-of-type 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)E:last-of-type 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)E:only-child 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)E:only-of-type 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)E:not(selector) 匹配不符合当前选择器的任何元素 div:first-child、div:first-of-type、div :first-child和div :first-of-type的作用和区别 （注意空格的作用）:first-child选择器是选择父元素的第一个子元素，而:first-of-type选择器则是选择第一个这个类/这个标签的子元素。而空格无非是后代选择器而已，所以这四个选择器的意义分别是： div:first-child：是第一个元素的 div 标签div:first-of-type：第一个 div 标签div :first-child：div 标签下的第一个元素div :first-of-type：div 标签下每个标签的第一个元素 范例： 12345678910111213&lt;style&gt;.item1:first-child&#123; color: red;&#125;.item1:first-of-type&#123; background: blue;&#125;&lt;/style&gt;&lt;div class="ct"&gt; &lt;p class="item1"&gt;aa&lt;/p&gt; &lt;h3 class="item1"&gt;bb&lt;/h3&gt; &lt;h3 class="item1"&gt;ccc&lt;/h3&gt;&lt;/div&gt; aabbccc .item1:first-child{ color: red; } .item1:first-of-type{ background: blue; } 解释：.item1:first-child选中了item1类中第一个元素，所以内容为“aa”的p标签变红色了。.item1:first-of-type选中了item1类中所有的标签的第一个元素，所以p标签和第一个h3标签的背景变蓝了。]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css基础]]></title>
    <url>%2F2017%2F12%2Fcss%E5%9F%BA%E7%A1%80.html</url>
    <content type="text"><![CDATA[CSS的全称是什么?层叠样式表（英语：Cascading Style Sheets，简写CSS），一种用来为结构化文档（如HTML文档或XML应用）添加样式（字体、间距和颜色等）的计算机语言，由W3C定义和维护。 CSS有几种引入方式? link 和@import 有什么区别?CSS有几种引入方式四种，分别为行内样式，内嵌样式和外联样式以及@import link 和@import 有什么区别 link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。 link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。所以有时候浏览@import加载CSS的页面时开始会没有样式（就是闪烁）。 link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。 link支持使用Javascript控制DOM去改变样式；而@import不支持。 以下这几种文件路径分别用在什么地方，代表什么意思? css/a.css相对路径，当前目录下css文件夹内a.css文件 ./css/a.css相对路径，同级目录下css文件夹内a.css文件 b.css相对路径，与当前文档同级目录下b.css文件 ../imgs/a.png相对路径，上级文件夹下imgs文件夹内a.png文件 /Users/hunger/project/css/a.css绝对路径，根目录下对应路径的文件 /static/css/a.css绝对路径，根目录下对应路径的文件 http://cdn.jirengu.com/kejian1/8-1.png绝对路径，表示饥人谷该网站kejian1目录下的名为8-1.png的图片地址 列出5条以上html和 css 的书写规范 一次缩进2个空格，不要使用 tab 或者混合 tab 和空格的缩进。 HTML 元素名称，属性，属性值（除非 text/CDATA），CSS 选择器，属性，属性值应该使用小写。 结尾切勿加空格空格不仅多余，而且在比较代码时会更麻烦。 在 HTML 中通过指定编码方式，CSS 中不需要指定，因为默认是 UTF-8。 使用注释来解释代码：包含的模块，功能以及优点。]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[form表单]]></title>
    <url>%2F2017%2F12%2Fform%E8%A1%A8%E5%8D%95.html</url>
    <content type="text"><![CDATA[form表单有什么作用？有哪些常用的input 标签，分别有什么作用？表单在网页中主要负责数据采集功能。一个表单有三个基本组成部分： 表单标签：这里面包含了处理表单数据所用CGI程序的URL以及数据提交到服务器的方法。 表单域：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等。 表单按钮：包括提交按钮、复位按钮和一般按钮；用于将数据传送到服务器上的CGI脚本或者取消输入，还可以用表单按钮来控制其他定义了处理 常见的input标签: 标签 作用 text 单行文本框 password 密码框 checkbox 多选输入框 radio 单选按钮 file 上传文件 hidden 隐藏域 submit 数据提交按钮 button 普通按钮 post 和 get 方式的区别 GET提交：请求的数据会附在URL之后(就是把数据放置在HTTP协议头中)，以?分割URL和传输数据，多个参数用&amp;连接。如果数据是英文字母数字，原样发送，如果是空格，转换为+，如果是中文其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中%XX中的XX为该符号以16进制表示的ASCII。示例：点击提交,地址跳转为 POST提交：把提交的数据放置在是HTTP包的包体中。示例：点击提交后信息并没有显示在地址栏里面因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变。 传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制 而在实际开发中存在的限制主要有： GET: 特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2K+35。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。 POST: 由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。 name属性 作为可与服务器交互数据的HTML元素的服务器端的标示，比如input、select、textarea、和button等。我们可以在服务器端根据其Name通过Request.Params取得元素提交的值。 HTML元素Input type=’radio’分组，我们知道radio button控件在同一个分组类，check操作是mutex的，同一时间只能选中一个radio，这个分组就是根据相同的Name属性来实现的。 建立页面中的锚点，我们知道&lt;a href=&quot;URL&quot;&gt;link&lt;/a&gt;是获得一个页面超级链接，如果不用href属性，而改用Name，如：&lt;a name=&quot;PageBottom&quot;&gt;&lt;/a&gt;，我们就获得了一个页面锚点。 作为对象的Identity，如Applet、Object、Embed等元素。比如在Applet对象实例中，我们将使用其Name来引用该对象。 在IMG元素和MAP元素之间关联的时候，如果要定义IMG的热点区域，需要使用其属性usemap，使usemap=”#name”(被关联的MAP元素的Name)。 某些特定元素的属性，如attribute，meta和param。例如为Object定义参数或Meta中。 radio如何分组在同一个分组里，name属性要有相同的值。12&lt;input type="radio" name="gender" value="male"&gt;&lt;input type="radio" name="gender" value="female"&gt; placeholder 属性有什么作用?可以在文本输入框内显示默认的提示字符 type=hidden隐藏域有什么作用? 举例说明 隐藏数据一起发送给服务器。 作为LocalStorage的替代品。 当有多个submit按钮时，可以用于确认是哪个按钮提交的表单。 可以用于联系多个表单。 作为全局变量使用。 作为父窗口的隐藏域，对小窗口传参。 input type=’submit’ 和type=’button’ 有什么区别在一个页面上话一个按钮有四种方法：1234567&lt;!-- 这就是一个按钮。如果你不写javascript 的话，按下去什么也不会发生。 --&gt;&lt;input type="button"&gt;&lt;!-- 这样的按钮用户点击之后会自动提交 form，除非你写了javascript 阻止它。 --&gt;&lt;input type="submit" /&gt;&lt;!-- 这个按钮放在 form 中也会点击自动提交，比前两个的优点是按钮的内容不光可以有文字，还可以有图片等多媒体内容。（当然，前两个用图片背景也可以做到）。它的缺点是不同的浏览器得到的 value 值不同；可能还有其他的浏览器兼容问题 --&gt;&lt;button&gt;&lt;!-- 其他标签，例如 a, img, span, div，然后用图片把它伪装成一个按钮。 --&gt;]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端利用动态rem实现自适应布局（一）]]></title>
    <url>%2F2017%2F12%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%88%A9%E7%94%A8%E5%8A%A8%E6%80%81rem%E5%AE%9E%E7%8E%B0%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[什么是rem这个单位代表根元素的 font-size 大小（例如 &lt;html&gt; 元素的font-size）当用在根元素的font-size上面时 ，它代表了它的初始值(译者注:默认的初始值是html的默认的font-size大小,比如当未在根元素上面设置font-size大小的时候,此时的1rem==1em,当设置font-size=2rem的时候,就使得页面中1rem的大小相当于html的根字体默认大小的2倍,当然此时页面中字体的大小也是html的根字体默认大小的2倍)。 自适应的精髓就是让盒子的大小，间距等与视窗的大小相关。如何用rem做到这一点？我们可以通过js来获取视窗的宽度，然后给html一个font-size值，让两者关联起来 有这样一个需求。有四个div盒子，每个盒子的宽度是高度的两倍，盒子中间的间距是周围间距的两倍，效果如下。并且在不同屏幕宽度小都能呈现出相同的效果 123var pageWidth = window.innerWidth document.write(`&lt;style&gt;html&#123;font-size:$&#123;pageWidth/10&#125;px;&#125;&lt;/style&gt;`) &lt;/script&gt; 12345678&lt;body&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt;box1&lt;/div&gt; &lt;div class="child"&gt;box2&lt;/div&gt; &lt;div class="child"&gt;box3&lt;/div&gt; &lt;div class="child"&gt;box4&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 12345678910111213141516171819* &#123; margin: 0; padding: 0; box-sizing: border-box; &#125;body &#123; font-size: 16px; &#125;clear::after &#123; content: ''; display: block; clear: both; &#125;.child &#123; width: 4rem; height: 2rem; margin: 0.5rem 0.5rem; float: left; background: #8e8585; &#125; 这样有一个问题，我每次都要计算才能得到给多少rem值，这样很麻烦。我们可以通多scss里面的函数解决这个问题。123456789101112131415161718192021@function px2rem($px)&#123; @return $px/$designWidth *10+ rem&#125;$designWidth : 320;* &#123;margin: 0;padding: 0;box-sizing: border-box;&#125;body &#123;font-size: 16px;&#125;clear::after&#123; content: ''; display: block; clear: both;&#125;.child &#123; width: px2rem(128); height: px2rem(64); margin: px2rem(16) px2rem(16); float: left; background: #8e8585;&#125; 结尾：这只是一个简单的利用动态rem实现自适应的思路，更多的细节，需要持续关注。附上一篇大漠老师的文章使用Flexible实现手淘H5页面的终端适配]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML知识]]></title>
    <url>%2F2017%2F12%2FHTML%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[HTML、XML、XHTML 有什么区别HTML、XML和XHTML都是标准通用标记语言的一个子集。 HTML被设计用来显示数据，其焦点是数据的外观,是最早写网页的语言，但是由于时间早，规范不是很好，大小写混写且编码不规范； XML被设计用来传输和存储数据，其焦点是数据的内容。 XHTML是更严格更纯净的 HTML 版本，是作为一种 XML 应用被重新定义的 HTML，设计的目的是为了取代HTML以适应未来网络更多的需求。 它们都可以用来开发网页，但就目前来看，网页开发中HTML还是占绝对的主流，现在最新版本HTML5也备受推崇。可拓展标记语言XML广泛运用于各种应用程序中数据的存储（例如各种配置文件）和应用程序间的数据传输，可以说是一项必须掌握的技术。至于可扩展超文本标记语言XHTML，在2009年W3C已经宣布停止了对XHTML2的开发，转而大力支持HTML5。 怎样理解 HTML 语义化语义化的HTML就是写出的HTML代码，根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。语义化有助于： 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重。 在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看。 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 怎样理解内容与样式分离的原则 写 HTML 仅处理内容，只考虑 HTML 的结构和语义化，避免出现属性样式。 写 JS 的时候，尽量不使用 JS直接操作样式。 页面展现的所有样式，都由CSS来负责实现。 有哪些常见的meta标签12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- 关键字，搜所引擎 SEO --&gt;&lt;!-- 关键字，搜所引擎 SEO --&gt;&lt;meta http-equiv="keywords" content="关键字1,关键字2,..."&gt; &lt;!-- 页面描述 --&gt;&lt;meta http-equiv="description" content="网页描述"&gt; &lt;!-- content的取值为webkit,ie-comp,ie-stand之一，区分大小写，分别代表用webkit内核，IE兼容内核，IE标准内核。 --&gt;&lt;meta name="renderer" content="webkit|ie-comp|ie-stand"&gt;&lt;!-- 若页面需默认用极速核，增加标签： --&gt;&lt;meta name="renderer" content="webkit"&gt;&lt;!-- 若页面需默认用ie兼容内核，增加标签： --&gt;&lt;meta name="renderer" content="ie-comp"&gt;&lt;!-- 若页面需默认用ie标准内核，增加标签： --&gt;&lt;meta name="renderer" content="ie-stand"&gt;&lt;!-- 如果安装了GCF，则使用GCF来渲染页面，如果没有安装GCF，则使用最高版本的IE内核进行渲染。X-UA-Compatible：这是个是IE8的专用标记,用来指定IE8浏览器去模拟某个特定版本的IE浏览器的渲染方式(比如人见人烦的IE6)，以此来解决部分兼容问题。 --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" &gt;&lt;!-- 强制页面在当前窗口以独立页面显示。 --&gt;&lt;meta http-equiv="Window-target" content="_top"&gt;&lt;!-- 自动刷新，并指向新的页面 --&gt;&lt;meta http-equiv="Refresh" content="2；URL=http://"&gt;&lt;!-- 禁止浏览器缓存 --&gt;&lt;!-- 是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出用法： --&gt;&lt;meta http-equiv="pragram" content="no-cache"&gt; &lt;!-- 清除缓存（再访问这个网站要重新下载！） --&gt;&lt;meta http-equiv="cache-control" content="no-cache, must-revalidate"&gt; &lt;!-- 设定网页的到期时间 --&gt;&lt;meta http-equiv="expires" content="0"&gt; &lt;!-- 手机端 --&gt;&lt;meta name="format-detection" content="telphone=no, email=no"/&gt;&lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;&lt;meta name="apple-mobile-web-app-status-bar-style" content="black"/&gt;&lt;!-- 设置苹果工具栏颜色 --&gt;&lt;!-- 不让百度转码 --&gt;&lt;meta http-equiv="Cache-Control" content="no-siteapp" /&gt;&lt;!-- 不缓存 --&gt;&lt;meta http-equiv="cache-control" content="no-cache" /&gt;&lt;!-- 初始化设备 --&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimal-ui" /&gt;&lt;!-- 网站开启对iphone私有 web app 程序的支持 --&gt;&lt;meta content="yes" name="apple-mobile-web-app-capable" /&gt;&lt;!-- 改变顶部状态条的颜色 iphone私有的属性--&gt;&lt;meta content="black" name="apple-mobile-web-app-status-bar-style" /&gt; 文档声明的作用?严格模式和混杂模式指什么?&lt;!doctype html&gt;的作用文档声明的作用文档声明指出阅读程序应该用什么规则集来解释文档中的标记。在web文档的情况下，“阅读程序”通常是浏览器或者校验器这样的一个程序，“规则”则是w3c所发布的一个文档类型定义（dtd）中包含的规则。每个dtd都包括一系列标记、attributes和properties，它们用于标记web文档的内容；此外还包括一些规则，它们规定了哪些标记能出现在其他哪些标记中。每个web建议标准（比如html 4 frameset和xhtml 1.0 transitional）都有自己的dtd。假如文档中的标记不遵循doctype声明所指定的dtd，这个文档除了不能通过代码校验之外，还有可能无法在浏览器中正确显示。对于标记不一致的问题，浏览器相较于校验器来说更宽容。但是，不正确的doctype声明经常导致网页不正确显示，或者导致它们根本不能显示。 严格模式和混杂模式指什么严格模式：又称标准模式，是指浏览器按照 W3C 标准解析代码。 混杂模式：又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码。 如何区分：浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。 如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。（严格 DTD ——严格模式）包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。（DTD不存在或者格式不正确——混杂模式）HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。（ HTML5 没有严格和混杂之分）意义：严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，每个浏览器都有自己的解析模式。 &lt;!doctype html&gt;的作用声明文档的解析类型(document.compatMode)，避免浏览器的怪异模式 document.compatMode：BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。CSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面。 这个属性会被浏览器识别并使用，但是如果你的页面没有DOCTYPE的声明，那么compatMode默认就是BackCompat,这也就是绝望和黑暗的开始 – 浏览器按照自己的方式解析渲染页面，那么，在不同的浏览器就会显示不同的样式。如果你的页面添加了&lt;!DOCTYPE html&gt;那么，那么就等同于开启了标准模式，那么浏览器就得老老实实的按照W3C的标准解析渲染页面，这样一来，你的页面在所有的浏览器里显示的就都是一个样子了。这就是&lt;!DOCTYPE html&gt;的作用。 浏览器乱码的原因是什么？如何解决造成html网页乱码原因主要是html源代码内中文字内容与html编码不同造成。但无论是哪种情况造成乱码解决方法都是在网页开始时候设置网页编码 常见的浏览器有哪些，什么内核 浏览器 市场占有率 内核 Chrome 58.64% WebKit/Chromium引擎 Internet Explorer 18.95% Trident Firefox 11.79% Gecko Edge 5.61% Trident Safari 3.37% WebKit Opera 1.18% Presto]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
</search>
